{"version":3,"file":"map.umd.min.js","sources":["../../../node_modules/tslib/tslib.es6.js","../../../node_modules/rxjs/src/internal/util/isFunction.ts","../../../node_modules/rxjs/src/internal/config.ts","../../../node_modules/rxjs/src/internal/util/hostReportError.ts","../../../node_modules/rxjs/src/internal/Observer.ts","../../../node_modules/rxjs/src/internal/util/isObject.ts","../../../node_modules/rxjs/src/internal/util/tryCatch.ts","../../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../../../node_modules/rxjs/src/internal/Subscription.ts","../../../node_modules/rxjs/src/internal/symbol/rxSubscriber.ts","../../../node_modules/rxjs/src/internal/Subscriber.ts","../../../node_modules/rxjs/src/internal/Observable.ts","../../../node_modules/rxjs/src/internal/util/toSubscriber.ts","../../../node_modules/rxjs/src/internal/util/pipe.ts","../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../../node_modules/rxjs/src/internal/SubjectSubscription.ts","../../../node_modules/rxjs/src/internal/Subject.ts","../../../node_modules/rxjs/src/internal/operators/refCount.ts","../../../node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","../../../node_modules/rxjs/src/internal/BehaviorSubject.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../../../node_modules/rxjs/src/internal/scheduler/Action.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueAction.ts","../../../node_modules/rxjs/src/internal/Scheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/queue.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","../../../node_modules/rxjs/src/internal/observable/empty.ts","../../../node_modules/rxjs/src/internal/util/isScheduler.ts","../../../node_modules/rxjs/src/internal/util/subscribeToArray.ts","../../../node_modules/rxjs/src/internal/observable/fromArray.ts","../../../node_modules/rxjs/src/internal/observable/of.ts","../../../node_modules/rxjs/src/internal/observable/scalar.ts","../../../node_modules/rxjs/src/internal/observable/throwError.ts","../../../node_modules/rxjs/src/internal/Notification.ts","../../../node_modules/rxjs/src/internal/operators/observeOn.ts","../../../node_modules/rxjs/src/internal/ReplaySubject.ts","../../../node_modules/rxjs/src/internal/util/Immediate.ts","../../../node_modules/rxjs/src/internal/scheduler/async.ts","../../../node_modules/rxjs/src/internal/util/identity.ts","../../../node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","../../../node_modules/rxjs/src/internal/util/EmptyError.ts","../../../node_modules/rxjs/src/internal/operators/map.ts","../../../node_modules/rxjs/src/internal/OuterSubscriber.ts","../../../node_modules/rxjs/src/internal/InnerSubscriber.ts","../../../node_modules/rxjs/src/internal/util/subscribeToPromise.ts","../../../node_modules/rxjs/src/internal/symbol/iterator.ts","../../../node_modules/rxjs/src/internal/util/subscribeToIterable.ts","../../../node_modules/rxjs/src/internal/util/subscribeToObservable.ts","../../../node_modules/rxjs/src/internal/util/isPromise.ts","../../../node_modules/rxjs/src/internal/util/subscribeTo.ts","../../../node_modules/rxjs/src/internal/util/subscribeToResult.ts","../../../node_modules/rxjs/src/internal/observable/combineLatest.ts","../../../node_modules/rxjs/src/internal/observable/from.ts","../../../node_modules/rxjs/src/internal/util/isInteropObservable.ts","../../../node_modules/rxjs/src/internal/observable/fromObservable.ts","../../../node_modules/rxjs/src/internal/observable/fromPromise.ts","../../../node_modules/rxjs/src/internal/util/isIterable.ts","../../../node_modules/rxjs/src/internal/observable/fromIterable.ts","../../../node_modules/ramda/es/internal/_isPlaceholder.js","../../../node_modules/ramda/es/internal/_curry1.js","../../../node_modules/ramda/es/always.js","../../../node_modules/ramda/es/internal/_curry2.js","../../../node_modules/ramda/es/add.js","../../../node_modules/ramda/es/curryN.js","../../../node_modules/ramda/es/internal/_curry3.js","../../../node_modules/ramda/es/internal/_isArray.js","../../../node_modules/ramda/es/max.js","../../../node_modules/ramda/es/internal/_isArrayLike.js","../../../node_modules/ramda/es/bind.js","../../../node_modules/ramda/es/internal/_reduce.js","../../../node_modules/ramda/es/internal/_xmap.js","../../../node_modules/ramda/es/internal/_has.js","../../../node_modules/ramda/es/internal/_isArguments.js","../../../node_modules/ramda/es/keys.js","../../../node_modules/ramda/es/isNil.js","../../../node_modules/ramda/es/map.js","../../../node_modules/ramda/es/path.js","../../../node_modules/ramda/es/prop.js","../../../node_modules/ramda/es/pluck.js","../../../node_modules/ramda/es/ap.js","../../../node_modules/ramda/es/liftN.js","../../../node_modules/ramda/es/lift.js","../../../node_modules/ramda/es/internal/_xchain.js","../../../node_modules/ramda/es/chain.js","../../../node_modules/ramda/es/internal/_makeFlat.js","../../../node_modules/ramda/es/type.js","../../../node_modules/ramda/es/not.js","../../../node_modules/ramda/es/internal/_checkForMethod.js","../../../node_modules/ramda/es/slice.js","../../../node_modules/ramda/es/tail.js","../../../node_modules/ramda/es/reverse.js","../../../node_modules/ramda/es/identical.js","../../../node_modules/ramda/es/equals.js","../../../node_modules/ramda/es/internal/_toISOString.js","../../../node_modules/ramda/es/internal/_xfilter.js","../../../node_modules/ramda/es/reject.js","../../../node_modules/ramda/es/internal/_complement.js","../../../node_modules/ramda/es/converge.js","../../../node_modules/ramda/es/internal/_xreduceBy.js","../../../node_modules/ramda/es/reduceBy.js","../../../node_modules/ramda/es/internal/_xdropRepeatsWith.js","../../../node_modules/ramda/es/nth.js","../../../node_modules/ramda/es/dropRepeatsWith.js","../../../node_modules/ramda/es/flip.js","../../../node_modules/ramda/es/invoker.js","../../../node_modules/ramda/es/internal/_isFunction.js","../../../node_modules/ramda/es/juxt.js","../../../node_modules/ramda/es/multiply.js","../../../node_modules/ramda/es/pickAll.js","../../../node_modules/ramda/es/partialRight.js","../../../node_modules/ramda/es/trim.js","~/@ngui/map/tmp/services/util.ts","~/@ngui/map/tmp/directives/base-map-directive.ts","../../../node_modules/rxjs/src/internal/operators/debounceTime.ts","../../../node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts","../../../node_modules/rxjs/src/internal/operators/filter.ts","../../../node_modules/rxjs/src/internal/operators/tap.ts","../../../node_modules/rxjs/src/internal/operators/throwIfEmpty.ts","../../../node_modules/rxjs/src/internal/operators/take.ts","../../../node_modules/rxjs/src/internal/operators/first.ts","../../../node_modules/rxjs/src/internal/operators/multicast.ts","../../../node_modules/rxjs/src/internal/operators/publishReplay.ts","../../../node_modules/rxjs/src/internal/operators/takeUntil.ts","../../../node_modules/rxjs/src/internal/operators/windowToggle.ts","~/@ngui/map/tmp/services/config.ts","~/@ngui/map/tmp/services/api-loader.ts","~/@ngui/map/tmp/services/geo-coder.ts","~/@ngui/map/tmp/services/map-loaded.service.ts","~/@ngui/map/tmp/services/option-builder.ts","~/@ngui/map/tmp/services/map.service.ts","~/@ngui/map/tmp/services/marker-clusterer-provider.service.ts","~/@ngui/map/tmp/services/navigator-geolocation.ts","~/@ngui/map/tmp/components/custom-marker/services/custom-marker-overlay-view.service.ts","~/@ngui/map/tmp/components/custom-marker/mixins/custom-marker-overlay-view.mixin.ts","~/@ngui/map/tmp/components/ngui-map.component.ts","~/@ngui/map/tmp/directives/bicycling-layer.ts","~/@ngui/map/tmp/components/info-window.ts","~/@ngui/map/tmp/directives/circle.ts","~/@ngui/map/tmp/directives/data-layer.ts","~/@ngui/map/tmp/directives/directions-renderer.ts","~/@ngui/map/tmp/directives/drawing-manager.ts","~/@ngui/map/tmp/directives/ground-overlay.ts","~/@ngui/map/tmp/directives/heatmap-layer.ts","~/@ngui/map/tmp/directives/kml-layer.ts","~/@ngui/map/tmp/directives/marker.ts","~/@ngui/map/tmp/directives/places-auto-complete.ts","~/@ngui/map/tmp/directives/polygon.ts","~/@ngui/map/tmp/directives/polyline.ts","~/@ngui/map/tmp/directives/street-view-panorama.ts","~/@ngui/map/tmp/directives/traffic-layer.ts","~/@ngui/map/tmp/directives/transit-layer.ts","~/@ngui/map/tmp/components/custom-marker/custom-marker.component.ts","~/@ngui/map/tmp/directives/custom-marker-cluster.directive.ts","../../../node_modules/rxjs/src/internal/operators/combineLatest.ts","~/@ngui/map/tmp/ngui-map.module.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\nexport function hostReportError(err: any) {\n  setTimeout(() => { throw err; });\n}","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n\n  public readonly name = 'UnsubscriptionError';\n\n  constructor(public errors: any[]) {\n    super(errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (Object as any).setPrototypeOf(this, UnsubscriptionError.prototype);\n  }\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","export const rxSubscriber =\n  (typeof Symbol === 'function' && typeof Symbol.for === 'function')\n    ? Symbol.for('rxSubscriber')\n    : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): For situations where Node has multiple copies of rxjs in\n          // node_modules, we cannot rely on `instanceof` checks\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```javascript\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```javascript\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```javascript\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<R>(...operations: OperatorFunction<any, any>[]): Observable<R>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport class ObjectUnsubscribedError extends Error {\n\n  public readonly name = 'ObjectUnsubscribedError';\n\n  constructor() {\n    super('object unsubscribed');\n    (Object as any).setPrototypeOf(this, ObjectUnsubscribedError.prototype);\n  }\n}\n","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nconst connectableProto = <any>ConnectableObservable.prototype;\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = {\n  operator: { value: null },\n  _refCount: { value: 0, writable: true },\n  _subject: { value: null, writable: true },\n  _connection: { value: null, writable: true },\n  _subscribe: { value: connectableProto._subscribe },\n  _isComplete: { value: connectableProto._isComplete, writable: true },\n  getSubject: { value: connectableProto.getSubject },\n  connect: { value: connectableProto.connect },\n  refCount: { value: connectableProto.refCount }\n};\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { SubscriptionLike } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\n\n/**\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    if (subscription && !(<SubscriptionLike>subscription).closed) {\n      subscriber.next(this._value);\n    }\n    return subscription;\n  }\n\n  getValue(): T {\n    if (this.hasError) {\n      throw this.thrownError;\n    } else if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return this._value;\n    }\n  }\n\n  next(value: T): void {\n    super.next(this._value = value);\n  }\n}\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class QueueAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: QueueScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return (delay > 0 || this.closed) ?\n      super.execute(state, delay) :\n      this._execute(state, delay) ;\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport class Scheduler implements SchedulerLike {\n\n  /**\n   * Note: the extra arrow function wrapper is to make testing by overriding\n   * Date.now easier.\n   * @nocollapse\n   */\n  public static now: () => number = () => Date.now();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```javascript\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```javascript\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\n\nexport const queue = new QueueScheduler(QueueAction);\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * `scheduler`. It is preferrable to use this over `empty()`.\n */\nexport const EMPTY = new Observable<never>(subscriber => subscriber.complete());\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * ![](empty.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then complete\n * ```javascript\n * const result = empty().pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'\n * ```javascript\n * const interval$ = interval(1000);\n * result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throwError}\n *\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using EMPTY constant.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nexport function emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>(subscriber => scheduler.schedule(() => subscriber.complete()));\n}\n","import { SchedulerLike } from '../types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  if (!subscriber.closed) {\n    subscriber.complete();\n  }\n};\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToArray } from '../util/subscribeToArray';\n\nexport function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToArray(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let i = 0;\n      sub.add(scheduler.schedule(function () {\n        if (i === input.length) {\n          subscriber.complete();\n          return;\n        }\n        subscriber.next(input[i++]);\n        if (!subscriber.closed) {\n          sub.add(this.schedule());\n        }\n      }));\n      return sub;\n    });\n  }\n}\n","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { fromArray } from './fromArray';\nimport { empty } from './empty';\nimport { scalar } from './scalar';\nimport { Observable } from '../Observable';\n\n/* tslint:disable:max-line-length */\nexport function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>;\nexport function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```javascript\n * of(10, 20, 30)\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: 10'\n * // 'next: 20'\n * // 'next: 30'\n *\n * ```\n *\n * Emit the array `[1,2,3]`\n *\n * ```javascript\n * of([1,2,3])\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: [1,2,3]'\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n * @method of\n * @owner Observable\n */\n\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  let scheduler = args[args.length - 1] as SchedulerLike;\n  if (isScheduler(scheduler)) {\n    args.pop();\n  } else {\n    scheduler = undefined;\n  }\n  switch (args.length) {\n    case 0:\n      return empty(scheduler);\n    case 1:\n      return scheduler ? fromArray(args as T[], scheduler) : scalar(args[0] as T);\n    default:\n      return fromArray(args as T[], scheduler);\n  }\n}\n","import { Observable } from '../Observable';\n\nexport function scalar<T>(value: T) {\n  const result = new Observable<T>(subscriber => {\n    subscriber.next(value);\n    subscriber.complete();\n  });\n  result._isScalar = true;\n  (result as any).value = value;\n  return result;\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits an error notification.\n *\n * <span class=\"informal\">Just emits 'error', and nothing else.\n * </span>\n *\n * ![](throw.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the error notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then emit an error\n * ```javascript\n * import { throwError, concat, of } from 'rxjs';\n *\n * const result = concat(of(7), throwError(new Error('oops!')));\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```javascript\n *\n * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13\n * ```javascript\n * import { throwError, interval, of } from 'rxjs';\n * import { mergeMap } from 'rxjs/operators';\n *\n * interval(1000).pipe(\n *   mergeMap(x => x === 13\n *     ? throwError('Thirteens are bad')\n *     : of('a', 'b', 'c')\n *   ),\n * ).subscribe(x => console.log(x), e => console.error(e));\n * ```\n * @see {@link Observable}\n * @see {@link empty}\n * @see {@link never}\n * @see {@link of}\n *\n * @param {any} error The particular Error to pass to the error notification.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the error notification.\n * @return {Observable} An error Observable: emits only the error notification\n * using the given error argument.\n * @static true\n * @name throw\n * @owner Observable\n */\nexport function throwError(error: any, scheduler?: SchedulerLike): Observable<never> {\n  if (!scheduler) {\n    return new Observable(subscriber => subscriber.error(error));\n  } else {\n    return new Observable(subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));\n  }\n}\n\ninterface DispatchArg {\n  error: any;\n  subscriber: Subscriber<any>;\n}\n\nfunction dispatch({ error, subscriber }: DispatchArg) {\n  subscriber.error(error);\n}\n","import { PartialObserver } from './types';\nimport { Observable } from './Observable';\nimport { empty } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport class Notification<T> {\n  hasValue: boolean;\n\n  constructor(public kind: string, public value?: T, public error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n  observe(observer: PartialObserver<T>): any {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n      case 'E':\n        return observer.error && observer.error(this.error);\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  }\n\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n      case 'E':\n        return error && error(this.error);\n      case 'C':\n        return complete && complete();\n    }\n  }\n\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') {\n      return this.observe(<PartialObserver<T>>nextOrObserver);\n    } else {\n      return this.do(<(value: T) => void>nextOrObserver, error, complete);\n    }\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n  toObservable(): Observable<T> {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return of(this.value);\n      case 'E':\n        return throwError(this.error);\n      case 'C':\n        return empty();\n    }\n    throw new Error('unexpected notification kind value');\n  }\n\n  private static completeNotification: Notification<any> = new Notification('C');\n  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);\n\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createNext<T>(value: T): Notification<T> {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n    return Notification.undefinedValueNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createError<T>(err?: any): Notification<T> {\n    return new Notification('E', undefined, err);\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   */\n  static createComplete(): Notification<any> {\n    return Notification.completeNotification;\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n * Ensure values in subscribe are called just before browser repaint.\n * ```javascript\n * const intervals = interval(10);                // Intervals are scheduled\n *                                                // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler),          // ...but we will observe on animationFrame\n * )                                              // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function observeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nexport class ObserveOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: SchedulerLike, private delay: number = 0) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\n  /** @nocollapse */\n  static dispatch(this: SchedulerAction<ObserveOnMessage>, arg: ObserveOnMessage) {\n    const { notification, destination } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  constructor(destination: Subscriber<T>,\n              private scheduler: SchedulerLike,\n              private delay: number = 0) {\n    super(destination);\n  }\n\n  private scheduleMessage(notification: Notification<any>): void {\n    this.add(this.scheduler.schedule(\n      ObserveOnSubscriber.dispatch,\n      this.delay,\n      new ObserveOnMessage(notification, this.destination)\n    ));\n  }\n\n  protected _next(value: T): void {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  protected _error(err: any): void {\n    this.scheduleMessage(Notification.createError(err));\n  }\n\n  protected _complete(): void {\n    this.scheduleMessage(Notification.createComplete());\n  }\n}\n\nexport class ObserveOnMessage {\n  constructor(public notification: Notification<any>,\n              public destination: PartialObserver<any>) {\n  }\n}\n","import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    const _events = this._events;\n    _events.push(value);\n    // Since this method is invoked in every next() call than the buffer\n    // can overgrow the max size only by one item\n    if (_events.length > this._bufferSize) {\n      _events.shift();\n    }\n\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    this._events.push(new ReplayEvent(this._getNow(), value));\n    this._trimBufferThenGetEvents();\n\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n","let nextHandle = 1;\n\nconst tasksByHandle: { [handle: string]: () => void } = {};\n\nfunction runIfPresent(handle: number) {\n  const cb = tasksByHandle[handle];\n  if (cb) {\n    cb();\n  }\n}\n\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    tasksByHandle[handle] = cb;\n    Promise.resolve().then(() => runIfPresent(handle));\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    delete tasksByHandle[handle];\n  },\n};\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```javascript\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```javascript\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","export function identity<T>(x: T): T {\n  return x;\n}\n","/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport class ArgumentOutOfRangeError extends Error {\n\n  public readonly name = 'ArgumentOutOfRangeError';\n\n  constructor() {\n    super('argument out of range');\n    (Object as any).setPrototypeOf(this, ArgumentOutOfRangeError.prototype);\n  }\n}\n","/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nexport class EmptyError extends Error {\n\n  public readonly name = 'EmptyError';\n\n  constructor() {\n    super('no elements in sequence');\n    (Object as any).setPrototypeOf(this, EmptyError.prototype);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, public outerValue: T, public outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { hostReportError } from './hostReportError';\n\nexport const subscribeToPromise = <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => {\n  promise.then(\n    (value) => {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    },\n    (err: any) => subscriber.error(err)\n  )\n  .then(null, hostReportError);\n  return subscriber;\n};\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n\n/**\n * @deprecated use {@link iterator} instead\n */\nexport const $$iterator = iterator;\n","import { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\n\nexport const subscribeToIterable = <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => {\n  const iterator = iterable[Symbol_iterator]();\n  do {\n    const item = iterator.next();\n    if (item.done) {\n      subscriber.complete();\n      break;\n    }\n    subscriber.next(item.value);\n    if (subscriber.closed) {\n      break;\n    }\n  } while (true);\n\n  // Finalize the iterator if it happens to be a Generator\n  if (typeof iterator.return === 'function') {\n    subscriber.add(() => {\n      if (iterator.return) {\n        iterator.return();\n      }\n    });\n  }\n\n  return subscriber;\n};\n","import { Subscriber } from '../Subscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport const subscribeToObservable = <T>(obj: any) => (subscriber: Subscriber<T>) => {\n  const obs = obj[Symbol_observable]();\n  if (typeof obs.subscribe !== 'function') {\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  } else {\n    return obs.subscribe(subscriber);\n  }\n};\n","export function isPromise(value: any): value is PromiseLike<any> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nimport { subscribeToArray } from './subscribeToArray';\nimport { subscribeToPromise } from './subscribeToPromise';\nimport { subscribeToIterable } from './subscribeToIterable';\nimport { subscribeToObservable } from './subscribeToObservable';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { Subscriber } from '../Subscriber';\n\nexport const subscribeTo = <T>(result: ObservableInput<T>) => {\n  if (result instanceof Observable) {\n    return (subscriber: Subscriber<T>) => {\n        if (result._isScalar) {\n        subscriber.next((result as any).value);\n        subscriber.complete();\n        return undefined;\n      } else {\n        return result.subscribe(subscriber);\n      }\n    };\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    return subscribeToObservable(result as any);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result as Promise<any>);\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    return subscribeToIterable(result as any);\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n","\nimport { ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeTo } from './subscribeTo';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription | void {\n  const destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  return subscribeTo(result)(destination);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { isScheduler  } from '../util/isScheduler';\nimport { isArray  } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Operator } from '../Operator';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { fromArray } from './fromArray';\n\nconst NONE = {};\n\n/* tslint:disable:max-line-length */\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: SchedulerLike): Observable<R>;\n\nexport function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<[T, T2]>;\nexport function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<[T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function combineLatest<T>(array: ObservableInput<T>[], scheduler?: SchedulerLike): Observable<T[]>;\nexport function combineLatest<R>(array: ObservableInput<any>[], scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R, scheduler?: SchedulerLike): Observable<R>;\n/** @deprecated resultSelector no longer supported, pipe to map instead */\nexport function combineLatest<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R, scheduler?: SchedulerLike): Observable<R>;\nexport function combineLatest<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): Observable<T[]>;\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R) | SchedulerLike>): Observable<R>;\nexport function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all that values but last\n * will be lost. On the other hand, if some Observable does not emit value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n * ## Examples\n * ### Combine two timer Observables\n * ```javascript\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * ### Combine an array of Observables\n * ```javascript\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000),   // emit 0 and then emit n after n seconds\n *     startWith(0),\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n *\n * ### Use project function to dynamically calculate the Body-Mass Index\n * ```javascript\n * * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest(weight, height).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\nexport function combineLatest<T, R>(...observables: Array<any | ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    (((...values: Array<any>) => R)) |\n                                                    SchedulerLike>): Observable<R> {\n  let resultSelector: (...values: Array<any>) => R =  null;\n  let scheduler: SchedulerLike = null;\n\n  if (isScheduler(observables[observables.length - 1])) {\n    scheduler = <SchedulerLike>observables.pop();\n  }\n\n  if (typeof observables[observables.length - 1] === 'function') {\n    resultSelector = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], resultSelector)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = <Array<Observable<any>>>observables[0];\n  }\n\n  return fromArray(observables, scheduler).lift(new CombineLatestOperator<T, R>(resultSelector));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private resultSelector?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond: number;\n\n  constructor(destination: Subscriber<R>, private resultSelector?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(NONE);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === NONE ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.resultSelector) {\n        this._tryResultSelector(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  }\n\n  private _tryResultSelector(values: any[]) {\n    let result: any;\n    try {\n      result = this.resultSelector.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Observable } from '../Observable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isIterable } from '../util/isIterable';\nimport { fromArray } from './fromArray';\nimport { fromPromise } from './fromPromise';\nimport { fromIterable } from './fromIterable';\nimport { fromObservable } from './fromObservable';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { ObservableInput, SchedulerLike } from '../types';\n\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport function from<T>(input: ObservableInput<ObservableInput<T>>, scheduler?: SchedulerLike): Observable<Observable<T>>;\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  if (!scheduler) {\n    if (input instanceof Observable) {\n      return input;\n    }\n    return new Observable<T>(subscribeTo(input));\n  }\n\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromObservable(input, scheduler);\n    } else if (isPromise(input)) {\n      return fromPromise(input, scheduler);\n    } else if (isArrayLike(input)) {\n      return fromArray(input, scheduler);\n    }  else if (isIterable(input) || typeof input === 'string') {\n      return fromIterable(input, scheduler);\n    }\n  }\n\n  throw new TypeError((input !== null && typeof input || input) + ' is not observable');\n}\n","import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return input && typeof input[Symbol_observable] === 'function';\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { subscribeToObservable } from '../util/subscribeToObservable';\nimport { InteropObservable, SchedulerLike, Subscribable } from '../types';\n\nexport function fromObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToObservable(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      sub.add(scheduler.schedule(() => {\n        const observable: Subscribable<T> = input[Symbol_observable]();\n        sub.add(observable.subscribe({\n          next(value) { sub.add(scheduler.schedule(() => subscriber.next(value))); },\n          error(err) { sub.add(scheduler.schedule(() => subscriber.error(err))); },\n          complete() { sub.add(scheduler.schedule(() => subscriber.complete())); },\n        }));\n      }));\n      return sub;\n    });\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToPromise } from '../util/subscribeToPromise';\n\nexport function fromPromise<T>(input: PromiseLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToPromise(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      sub.add(scheduler.schedule(() => input.then(\n        value => {\n          sub.add(scheduler.schedule(() => {\n            subscriber.next(value);\n            sub.add(scheduler.schedule(() => subscriber.complete()));\n          }));\n        },\n        err => {\n          sub.add(scheduler.schedule(() => subscriber.error(err)));\n        }\n      )));\n      return sub;\n    });\n  }\n}\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return input && typeof input[Symbol_iterator] === 'function';\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { subscribeToIterable } from '../util/subscribeToIterable';\n\nexport function fromIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  if (!scheduler) {\n    return new Observable<T>(subscribeToIterable(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let iterator: Iterator<T>;\n      sub.add(() => {\n        // Finalize generators\n        if (iterator && typeof iterator.return === 'function') {\n          iterator.return();\n        }\n      });\n      sub.add(scheduler.schedule(() => {\n        iterator = input[Symbol_iterator]();\n        sub.add(scheduler.schedule(function () {\n          if (subscriber.closed) {\n            return;\n          }\n          let value: T;\n          let done: boolean;\n          try {\n            const result = iterator.next();\n            value = result.value;\n            done = result.done;\n          } catch (err) {\n            subscriber.error(err);\n            return;\n          }\n          if (done) {\n            subscriber.complete();\n          } else {\n            subscriber.next(value);\n            this.schedule();\n          }\n        }));\n      }));\n      return sub;\n    });\n  }\n}\n","export default function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}","import _isPlaceholder from './_isPlaceholder';\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}","import _curry1 from './internal/_curry1';\n\n/**\n * Returns a function that always returns the given value. Note that for\n * non-primitives the value returned is a reference to the original value.\n *\n * This function is known as `const`, `constant`, or `K` (for K combinator) in\n * other languages and libraries.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig a -> (* -> a)\n * @param {*} val The value to wrap in a function\n * @return {Function} A Function :: * -> val.\n * @example\n *\n *      var t = R.always('Tee');\n *      t(); //=> 'Tee'\n */\nvar always = /*#__PURE__*/_curry1(function always(val) {\n  return function () {\n    return val;\n  };\n});\nexport default always;","import _curry1 from './_curry1';\nimport _isPlaceholder from './_isPlaceholder';\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}","import _curry2 from './internal/_curry2';\n\n/**\n * Adds two values.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Math\n * @sig Number -> Number -> Number\n * @param {Number} a\n * @param {Number} b\n * @return {Number}\n * @see R.subtract\n * @example\n *\n *      R.add(2, 3);       //=>  5\n *      R.add(7)(10);      //=> 17\n */\nvar add = /*#__PURE__*/_curry2(function add(a, b) {\n  return Number(a) + Number(b);\n});\nexport default add;","import _arity from './internal/_arity';\nimport _curry1 from './internal/_curry1';\nimport _curry2 from './internal/_curry2';\nimport _curryN from './internal/_curryN';\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\nvar curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\nexport default curryN;","import _curry1 from './_curry1';\nimport _curry2 from './_curry2';\nimport _isPlaceholder from './_isPlaceholder';\n\n/**\n * Optimized internal three-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\nexport default function _curry3(fn) {\n  return function f3(a, b, c) {\n    switch (arguments.length) {\n      case 0:\n        return f3;\n      case 1:\n        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        });\n      case 2:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _curry1(function (_c) {\n          return fn(a, b, _c);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n          return fn(_a, _b, c);\n        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n          return fn(_a, b, _c);\n        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n          return fn(a, _b, _c);\n        }) : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b, c);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b, c);\n        }) : _isPlaceholder(c) ? _curry1(function (_c) {\n          return fn(a, b, _c);\n        }) : fn(a, b, c);\n    }\n  };\n}","/**\n * Tests whether or not an object is an array.\n *\n * @private\n * @param {*} val The object to test.\n * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n * @example\n *\n *      _isArray([]); //=> true\n *      _isArray(null); //=> false\n *      _isArray({}); //=> false\n */\nexport default Array.isArray || function _isArray(val) {\n  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n};","import _curry2 from './internal/_curry2';\n\n/**\n * Returns the larger of its two arguments.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Relation\n * @sig Ord a => a -> a -> a\n * @param {*} a\n * @param {*} b\n * @return {*}\n * @see R.maxBy, R.min\n * @example\n *\n *      R.max(789, 123); //=> 789\n *      R.max('a', 'b'); //=> 'b'\n */\nvar max = /*#__PURE__*/_curry2(function max(a, b) {\n  return b > a ? b : a;\n});\nexport default max;","import _curry1 from './_curry1';\nimport _isArray from './_isArray';\nimport _isString from './_isString';\n\n/**\n * Tests whether or not an object is similar to an array.\n *\n * @private\n * @category Type\n * @category List\n * @sig * -> Boolean\n * @param {*} x The object to test.\n * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n * @example\n *\n *      _isArrayLike([]); //=> true\n *      _isArrayLike(true); //=> false\n *      _isArrayLike({}); //=> false\n *      _isArrayLike({length: 10}); //=> false\n *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n */\nvar _isArrayLike = /*#__PURE__*/_curry1(function isArrayLike(x) {\n  if (_isArray(x)) {\n    return true;\n  }\n  if (!x) {\n    return false;\n  }\n  if (typeof x !== 'object') {\n    return false;\n  }\n  if (_isString(x)) {\n    return false;\n  }\n  if (x.nodeType === 1) {\n    return !!x.length;\n  }\n  if (x.length === 0) {\n    return true;\n  }\n  if (x.length > 0) {\n    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n  }\n  return false;\n});\nexport default _isArrayLike;","import _arity from './internal/_arity';\nimport _curry2 from './internal/_curry2';\n\n/**\n * Creates a function that is bound to a context.\n * Note: `R.bind` does not provide the additional argument-binding capabilities of\n * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n *\n * @func\n * @memberOf R\n * @since v0.6.0\n * @category Function\n * @category Object\n * @sig (* -> *) -> {*} -> (* -> *)\n * @param {Function} fn The function to bind to context\n * @param {Object} thisObj The context to bind `fn` to\n * @return {Function} A function that will execute in the context of `thisObj`.\n * @see R.partial\n * @example\n *\n *      var log = R.bind(console.log, console);\n *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}\n *      // logs {a: 2}\n * @symb R.bind(f, o)(a, b) = f.call(o, a, b)\n */\nvar bind = /*#__PURE__*/_curry2(function bind(fn, thisObj) {\n  return _arity(fn.length, function () {\n    return fn.apply(thisObj, arguments);\n  });\n});\nexport default bind;","import _isArrayLike from './_isArrayLike';\nimport _xwrap from './_xwrap';\nimport bind from '../bind';\n\nfunction _arrayReduce(xf, acc, list) {\n  var idx = 0;\n  var len = list.length;\n  while (idx < len) {\n    acc = xf['@@transducer/step'](acc, list[idx]);\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n    idx += 1;\n  }\n  return xf['@@transducer/result'](acc);\n}\n\nfunction _iterableReduce(xf, acc, iter) {\n  var step = iter.next();\n  while (!step.done) {\n    acc = xf['@@transducer/step'](acc, step.value);\n    if (acc && acc['@@transducer/reduced']) {\n      acc = acc['@@transducer/value'];\n      break;\n    }\n    step = iter.next();\n  }\n  return xf['@@transducer/result'](acc);\n}\n\nfunction _methodReduce(xf, acc, obj, methodName) {\n  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));\n}\n\nvar symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n\nexport default function _reduce(fn, acc, list) {\n  if (typeof fn === 'function') {\n    fn = _xwrap(fn);\n  }\n  if (_isArrayLike(list)) {\n    return _arrayReduce(fn, acc, list);\n  }\n  if (typeof list['fantasy-land/reduce'] === 'function') {\n    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');\n  }\n  if (list[symIterator] != null) {\n    return _iterableReduce(fn, acc, list[symIterator]());\n  }\n  if (typeof list.next === 'function') {\n    return _iterableReduce(fn, acc, list);\n  }\n  if (typeof list.reduce === 'function') {\n    return _methodReduce(fn, acc, list, 'reduce');\n  }\n\n  throw new TypeError('reduce: list must be array or iterable');\n}","import _curry2 from './_curry2';\nimport _xfBase from './_xfBase';\n\nvar XMap = /*#__PURE__*/function () {\n  function XMap(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n  XMap.prototype['@@transducer/init'] = _xfBase.init;\n  XMap.prototype['@@transducer/result'] = _xfBase.result;\n  XMap.prototype['@@transducer/step'] = function (result, input) {\n    return this.xf['@@transducer/step'](result, this.f(input));\n  };\n\n  return XMap;\n}();\n\nvar _xmap = /*#__PURE__*/_curry2(function _xmap(f, xf) {\n  return new XMap(f, xf);\n});\nexport default _xmap;","export default function _has(prop, obj) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}","import _has from './_has';\n\nvar toString = Object.prototype.toString;\nvar _isArguments = function () {\n  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {\n    return toString.call(x) === '[object Arguments]';\n  } : function _isArguments(x) {\n    return _has('callee', x);\n  };\n};\n\nexport default _isArguments;","import _curry1 from './internal/_curry1';\nimport _has from './internal/_has';\nimport _isArguments from './internal/_isArguments';\n\n// cover IE < 9 keys issues\nvar hasEnumBug = ! /*#__PURE__*/{ toString: null }.propertyIsEnumerable('toString');\nvar nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n// Safari bug\nvar hasArgsEnumBug = /*#__PURE__*/function () {\n  'use strict';\n\n  return arguments.propertyIsEnumerable('length');\n}();\n\nvar contains = function contains(list, item) {\n  var idx = 0;\n  while (idx < list.length) {\n    if (list[idx] === item) {\n      return true;\n    }\n    idx += 1;\n  }\n  return false;\n};\n\n/**\n * Returns a list containing the names of all the enumerable own properties of\n * the supplied object.\n * Note that the order of the output array is not guaranteed to be consistent\n * across different JS platforms.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig {k: v} -> [k]\n * @param {Object} obj The object to extract properties from\n * @return {Array} An array of the object's own properties.\n * @see R.keysIn, R.values\n * @example\n *\n *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']\n */\nvar _keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? function keys(obj) {\n  return Object(obj) !== obj ? [] : Object.keys(obj);\n} : function keys(obj) {\n  if (Object(obj) !== obj) {\n    return [];\n  }\n  var prop, nIdx;\n  var ks = [];\n  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);\n  for (prop in obj) {\n    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {\n      ks[ks.length] = prop;\n    }\n  }\n  if (hasEnumBug) {\n    nIdx = nonEnumerableProps.length - 1;\n    while (nIdx >= 0) {\n      prop = nonEnumerableProps[nIdx];\n      if (_has(prop, obj) && !contains(ks, prop)) {\n        ks[ks.length] = prop;\n      }\n      nIdx -= 1;\n    }\n  }\n  return ks;\n};\nvar keys = /*#__PURE__*/_curry1(_keys);\nexport default keys;","import _curry1 from './internal/_curry1';\n\n/**\n * Checks if the input value is `null` or `undefined`.\n *\n * @func\n * @memberOf R\n * @since v0.9.0\n * @category Type\n * @sig * -> Boolean\n * @param {*} x The value to test.\n * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.\n * @example\n *\n *      R.isNil(null); //=> true\n *      R.isNil(undefined); //=> true\n *      R.isNil(0); //=> false\n *      R.isNil([]); //=> false\n */\nvar isNil = /*#__PURE__*/_curry1(function isNil(x) {\n  return x == null;\n});\nexport default isNil;","import _curry2 from './internal/_curry2';\nimport _dispatchable from './internal/_dispatchable';\nimport _map from './internal/_map';\nimport _reduce from './internal/_reduce';\nimport _xmap from './internal/_xmap';\nimport curryN from './curryN';\nimport keys from './keys';\n\n/**\n * Takes a function and\n * a [functor](https://github.com/fantasyland/fantasy-land#functor),\n * applies the function to each of the functor's values, and returns\n * a functor of the same shape.\n *\n * Ramda provides suitable `map` implementations for `Array` and `Object`,\n * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.\n *\n * Dispatches to the `map` method of the second argument, if present.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * Also treats functions as functors and will compose them together.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig Functor f => (a -> b) -> f a -> f b\n * @param {Function} fn The function to be called on every element of the input `list`.\n * @param {Array} list The list to be iterated over.\n * @return {Array} The new list.\n * @see R.transduce, R.addIndex\n * @example\n *\n *      var double = x => x * 2;\n *\n *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]\n *\n *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}\n * @symb R.map(f, [a, b]) = [f(a), f(b)]\n * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }\n * @symb R.map(f, functor_o) = functor_o.map(f)\n */\nvar map = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {\n  switch (Object.prototype.toString.call(functor)) {\n    case '[object Function]':\n      return curryN(functor.length, function () {\n        return fn.call(this, functor.apply(this, arguments));\n      });\n    case '[object Object]':\n      return _reduce(function (acc, key) {\n        acc[key] = fn(functor[key]);\n        return acc;\n      }, {}, keys(functor));\n    default:\n      return _map(fn, functor);\n  }\n}));\nexport default map;","import _curry2 from './internal/_curry2';\n\n/**\n * Retrieve the value at a given path.\n *\n * @func\n * @memberOf R\n * @since v0.2.0\n * @category Object\n * @typedefn Idx = String | Int\n * @sig [Idx] -> {a} -> a | Undefined\n * @param {Array} path The path to use.\n * @param {Object} obj The object to retrieve the nested property from.\n * @return {*} The data at `path`.\n * @see R.prop\n * @example\n *\n *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2\n *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined\n */\nvar path = /*#__PURE__*/_curry2(function path(paths, obj) {\n  var val = obj;\n  var idx = 0;\n  while (idx < paths.length) {\n    if (val == null) {\n      return;\n    }\n    val = val[paths[idx]];\n    idx += 1;\n  }\n  return val;\n});\nexport default path;","import _curry2 from './internal/_curry2';\nimport path from './path';\n\n/**\n * Returns a function that when supplied an object returns the indicated\n * property of that object, if it exists.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig s -> {s: a} -> a | Undefined\n * @param {String} p The property name\n * @param {Object} obj The object to query\n * @return {*} The value at `obj.p`.\n * @see R.path\n * @example\n *\n *      R.prop('x', {x: 100}); //=> 100\n *      R.prop('x', {}); //=> undefined\n */\n\nvar prop = /*#__PURE__*/_curry2(function prop(p, obj) {\n  return path([p], obj);\n});\nexport default prop;","import _curry2 from './internal/_curry2';\nimport map from './map';\nimport prop from './prop';\n\n/**\n * Returns a new list by plucking the same named property off all objects in\n * the list supplied.\n *\n * `pluck` will work on\n * any [functor](https://github.com/fantasyland/fantasy-land#functor) in\n * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig Functor f => k -> f {k: v} -> f v\n * @param {Number|String} key The key name to pluck off of each object.\n * @param {Array} f The array or functor to consider.\n * @return {Array} The list of values for the given key.\n * @see R.props\n * @example\n *\n *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]\n *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]\n *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}\n * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]\n * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]\n */\nvar pluck = /*#__PURE__*/_curry2(function pluck(p, list) {\n  return map(prop(p), list);\n});\nexport default pluck;","import _concat from './internal/_concat';\nimport _curry2 from './internal/_curry2';\nimport _reduce from './internal/_reduce';\nimport map from './map';\n\n/**\n * ap applies a list of functions to a list of values.\n *\n * Dispatches to the `ap` method of the second argument, if present. Also\n * treats curried functions as applicatives.\n *\n * @func\n * @memberOf R\n * @since v0.3.0\n * @category Function\n * @sig [a -> b] -> [a] -> [b]\n * @sig Apply f => f (a -> b) -> f a -> f b\n * @sig (a -> b -> c) -> (a -> b) -> (a -> c)\n * @param {*} applyF\n * @param {*} applyX\n * @return {*}\n * @example\n *\n *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]\n *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> [\"tasty pizza\", \"tasty salad\", \"PIZZA\", \"SALAD\"]\n *\n *      // R.ap can also be used as S combinator\n *      // when only two functions are passed\n *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'\n * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]\n */\nvar ap = /*#__PURE__*/_curry2(function ap(applyF, applyX) {\n  return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {\n    return applyF(x)(applyX(x));\n  } :\n  // else\n  _reduce(function (acc, f) {\n    return _concat(acc, map(f, applyX));\n  }, [], applyF);\n});\nexport default ap;","import _curry2 from './internal/_curry2';\nimport _reduce from './internal/_reduce';\nimport ap from './ap';\nimport curryN from './curryN';\nimport map from './map';\n\n/**\n * \"lifts\" a function to be the specified arity, so that it may \"map over\" that\n * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).\n *\n * @func\n * @memberOf R\n * @since v0.7.0\n * @category Function\n * @sig Number -> (*... -> *) -> ([*]... -> [*])\n * @param {Function} fn The function to lift into higher context\n * @return {Function} The lifted function.\n * @see R.lift, R.ap\n * @example\n *\n *      var madd3 = R.liftN(3, (...args) => R.sum(args));\n *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n */\nvar liftN = /*#__PURE__*/_curry2(function liftN(arity, fn) {\n  var lifted = curryN(arity, fn);\n  return curryN(arity, function () {\n    return _reduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));\n  });\n});\nexport default liftN;","import _curry1 from './internal/_curry1';\nimport liftN from './liftN';\n\n/**\n * \"lifts\" a function of arity > 1 so that it may \"map over\" a list, Function or other\n * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).\n *\n * @func\n * @memberOf R\n * @since v0.7.0\n * @category Function\n * @sig (*... -> *) -> ([*]... -> [*])\n * @param {Function} fn The function to lift into higher context\n * @return {Function} The lifted function.\n * @see R.liftN\n * @example\n *\n *      var madd3 = R.lift((a, b, c) => a + b + c);\n *\n *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]\n *\n *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);\n *\n *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]\n */\nvar lift = /*#__PURE__*/_curry1(function lift(fn) {\n  return liftN(fn.length, fn);\n});\nexport default lift;","import _curry2 from './_curry2';\nimport _flatCat from './_flatCat';\nimport map from '../map';\n\nvar _xchain = /*#__PURE__*/_curry2(function _xchain(f, xf) {\n  return map(f, _flatCat(xf));\n});\nexport default _xchain;","import _curry2 from './internal/_curry2';\nimport _dispatchable from './internal/_dispatchable';\nimport _makeFlat from './internal/_makeFlat';\nimport _xchain from './internal/_xchain';\nimport map from './map';\n\n/**\n * `chain` maps a function over a list and concatenates the results. `chain`\n * is also known as `flatMap` in some libraries\n *\n * Dispatches to the `chain` method of the second argument, if present,\n * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).\n *\n * @func\n * @memberOf R\n * @since v0.3.0\n * @category List\n * @sig Chain m => (a -> m b) -> m a -> m b\n * @param {Function} fn The function to map with\n * @param {Array} list The list to map over\n * @return {Array} The result of flat-mapping `list` with `fn`\n * @example\n *\n *      var duplicate = n => [n, n];\n *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]\n *\n *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]\n */\nvar chain = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/chain', 'chain'], _xchain, function chain(fn, monad) {\n  if (typeof monad === 'function') {\n    return function (x) {\n      return fn(monad(x))(x);\n    };\n  }\n  return _makeFlat(false)(map(fn, monad));\n}));\nexport default chain;","import _isArrayLike from './_isArrayLike';\n\n/**\n * `_makeFlat` is a helper function that returns a one-level or fully recursive\n * function based on the flag passed in.\n *\n * @private\n */\nexport default function _makeFlat(recursive) {\n  return function flatt(list) {\n    var value, jlen, j;\n    var result = [];\n    var idx = 0;\n    var ilen = list.length;\n\n    while (idx < ilen) {\n      if (_isArrayLike(list[idx])) {\n        value = recursive ? flatt(list[idx]) : list[idx];\n        j = 0;\n        jlen = value.length;\n        while (j < jlen) {\n          result[result.length] = value[j];\n          j += 1;\n        }\n      } else {\n        result[result.length] = list[idx];\n      }\n      idx += 1;\n    }\n    return result;\n  };\n}","import _curry1 from './internal/_curry1';\n\n/**\n * Gives a single-word string description of the (native) type of a value,\n * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n * attempt to distinguish user Object types any further, reporting them all as\n * 'Object'.\n *\n * @func\n * @memberOf R\n * @since v0.8.0\n * @category Type\n * @sig (* -> {*}) -> String\n * @param {*} val The value to test\n * @return {String}\n * @example\n *\n *      R.type({}); //=> \"Object\"\n *      R.type(1); //=> \"Number\"\n *      R.type(false); //=> \"Boolean\"\n *      R.type('s'); //=> \"String\"\n *      R.type(null); //=> \"Null\"\n *      R.type([]); //=> \"Array\"\n *      R.type(/[A-z]/); //=> \"RegExp\"\n *      R.type(() => {}); //=> \"Function\"\n *      R.type(undefined); //=> \"Undefined\"\n */\nvar type = /*#__PURE__*/_curry1(function type(val) {\n  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n});\nexport default type;","import _curry1 from './internal/_curry1';\n\n/**\n * A function that returns the `!` of its argument. It will return `true` when\n * passed false-y value, and `false` when passed a truth-y one.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Logic\n * @sig * -> Boolean\n * @param {*} a any value\n * @return {Boolean} the logical inverse of passed argument.\n * @see R.complement\n * @example\n *\n *      R.not(true); //=> false\n *      R.not(false); //=> true\n *      R.not(0); //=> true\n *      R.not(1); //=> false\n */\nvar not = /*#__PURE__*/_curry1(function not(a) {\n  return !a;\n});\nexport default not;","import _isArray from './_isArray';\n\n/**\n * This checks whether a function has a [methodname] function. If it isn't an\n * array it will execute that function otherwise it will default to the ramda\n * implementation.\n *\n * @private\n * @param {Function} fn ramda implemtation\n * @param {String} methodname property to check for a custom implementation\n * @return {Object} Whatever the return value of the method is.\n */\nexport default function _checkForMethod(methodname, fn) {\n  return function () {\n    var length = arguments.length;\n    if (length === 0) {\n      return fn();\n    }\n    var obj = arguments[length - 1];\n    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));\n  };\n}","import _checkForMethod from './internal/_checkForMethod';\nimport _curry3 from './internal/_curry3';\n\n/**\n * Returns the elements of the given list or string (or object with a `slice`\n * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).\n *\n * Dispatches to the `slice` method of the third argument, if present.\n *\n * @func\n * @memberOf R\n * @since v0.1.4\n * @category List\n * @sig Number -> Number -> [a] -> [a]\n * @sig Number -> Number -> String -> String\n * @param {Number} fromIndex The start index (inclusive).\n * @param {Number} toIndex The end index (exclusive).\n * @param {*} list\n * @return {*}\n * @example\n *\n *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']\n *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']\n *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']\n *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']\n *      R.slice(0, 3, 'ramda');                     //=> 'ram'\n */\nvar slice = /*#__PURE__*/_curry3( /*#__PURE__*/_checkForMethod('slice', function slice(fromIndex, toIndex, list) {\n  return Array.prototype.slice.call(list, fromIndex, toIndex);\n}));\nexport default slice;","import _checkForMethod from './internal/_checkForMethod';\nimport _curry1 from './internal/_curry1';\nimport slice from './slice';\n\n/**\n * Returns all but the first element of the given list or string (or object\n * with a `tail` method).\n *\n * Dispatches to the `slice` method of the first argument, if present.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig [a] -> [a]\n * @sig String -> String\n * @param {*} list\n * @return {*}\n * @see R.head, R.init, R.last\n * @example\n *\n *      R.tail([1, 2, 3]);  //=> [2, 3]\n *      R.tail([1, 2]);     //=> [2]\n *      R.tail([1]);        //=> []\n *      R.tail([]);         //=> []\n *\n *      R.tail('abc');  //=> 'bc'\n *      R.tail('ab');   //=> 'b'\n *      R.tail('a');    //=> ''\n *      R.tail('');     //=> ''\n */\nvar tail = /*#__PURE__*/_curry1( /*#__PURE__*/_checkForMethod('tail', /*#__PURE__*/slice(1, Infinity)));\nexport default tail;","import _curry1 from './internal/_curry1';\nimport _isString from './internal/_isString';\n\n/**\n * Returns a new list or string with the elements or characters in reverse\n * order.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig [a] -> [a]\n * @sig String -> String\n * @param {Array|String} list\n * @return {Array|String}\n * @example\n *\n *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]\n *      R.reverse([1, 2]);     //=> [2, 1]\n *      R.reverse([1]);        //=> [1]\n *      R.reverse([]);         //=> []\n *\n *      R.reverse('abc');      //=> 'cba'\n *      R.reverse('ab');       //=> 'ba'\n *      R.reverse('a');        //=> 'a'\n *      R.reverse('');         //=> ''\n */\nvar reverse = /*#__PURE__*/_curry1(function reverse(list) {\n  return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();\n});\nexport default reverse;","import _curry2 from './internal/_curry2';\n\n/**\n * Returns true if its arguments are identical, false otherwise. Values are\n * identical if they reference the same memory. `NaN` is identical to `NaN`;\n * `0` and `-0` are not identical.\n *\n * @func\n * @memberOf R\n * @since v0.15.0\n * @category Relation\n * @sig a -> a -> Boolean\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n * @example\n *\n *      var o = {};\n *      R.identical(o, o); //=> true\n *      R.identical(1, 1); //=> true\n *      R.identical(1, '1'); //=> false\n *      R.identical([], []); //=> false\n *      R.identical(0, -0); //=> false\n *      R.identical(NaN, NaN); //=> true\n */\nvar identical = /*#__PURE__*/_curry2(function identical(a, b) {\n  // SameValue algorithm\n  if (a === b) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return a !== 0 || 1 / a === 1 / b;\n  } else {\n    // Step 6.a: NaN == NaN\n    return a !== a && b !== b;\n  }\n});\nexport default identical;","import _curry2 from './internal/_curry2';\nimport _equals from './internal/_equals';\n\n/**\n * Returns `true` if its arguments are equivalent, `false` otherwise. Handles\n * cyclical data structures.\n *\n * Dispatches symmetrically to the `equals` methods of both arguments, if\n * present.\n *\n * @func\n * @memberOf R\n * @since v0.15.0\n * @category Relation\n * @sig a -> b -> Boolean\n * @param {*} a\n * @param {*} b\n * @return {Boolean}\n * @example\n *\n *      R.equals(1, 1); //=> true\n *      R.equals(1, '1'); //=> false\n *      R.equals([1, 2, 3], [1, 2, 3]); //=> true\n *\n *      var a = {}; a.v = a;\n *      var b = {}; b.v = b;\n *      R.equals(a, b); //=> true\n */\nvar equals = /*#__PURE__*/_curry2(function equals(a, b) {\n  return _equals(a, b, [], []);\n});\nexport default equals;","/**\n * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.\n */\nvar pad = function pad(n) {\n  return (n < 10 ? '0' : '') + n;\n};\n\nvar _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {\n  return d.toISOString();\n} : function _toISOString(d) {\n  return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';\n};\n\nexport default _toISOString;","import _curry2 from './_curry2';\nimport _xfBase from './_xfBase';\n\nvar XFilter = /*#__PURE__*/function () {\n  function XFilter(f, xf) {\n    this.xf = xf;\n    this.f = f;\n  }\n  XFilter.prototype['@@transducer/init'] = _xfBase.init;\n  XFilter.prototype['@@transducer/result'] = _xfBase.result;\n  XFilter.prototype['@@transducer/step'] = function (result, input) {\n    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;\n  };\n\n  return XFilter;\n}();\n\nvar _xfilter = /*#__PURE__*/_curry2(function _xfilter(f, xf) {\n  return new XFilter(f, xf);\n});\nexport default _xfilter;","import _complement from './internal/_complement';\nimport _curry2 from './internal/_curry2';\nimport filter from './filter';\n\n/**\n * The complement of [`filter`](#filter).\n *\n * Acts as a transducer if a transformer is given in list position. Filterable\n * objects include plain objects or any object that has a filter method such\n * as `Array`.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig Filterable f => (a -> Boolean) -> f a -> f a\n * @param {Function} pred\n * @param {Array} filterable\n * @return {Array}\n * @see R.filter, R.transduce, R.addIndex\n * @example\n *\n *      var isOdd = (n) => n % 2 === 1;\n *\n *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]\n *\n *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}\n */\nvar reject = /*#__PURE__*/_curry2(function reject(pred, filterable) {\n  return filter(_complement(pred), filterable);\n});\nexport default reject;","export default function _complement(f) {\n  return function () {\n    return !f.apply(this, arguments);\n  };\n}","import _curry2 from './internal/_curry2';\nimport _map from './internal/_map';\nimport curryN from './curryN';\nimport max from './max';\nimport pluck from './pluck';\nimport reduce from './reduce';\n\n/**\n * Accepts a converging function and a list of branching functions and returns\n * a new function. When invoked, this new function is applied to some\n * arguments, each branching function is applied to those same arguments. The\n * results of each branching function are passed as arguments to the converging\n * function to produce the return value.\n *\n * @func\n * @memberOf R\n * @since v0.4.2\n * @category Function\n * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)\n * @param {Function} after A function. `after` will be invoked with the return values of\n *        `fn1` and `fn2` as its arguments.\n * @param {Array} functions A list of functions.\n * @return {Function} A new function.\n * @see R.useWith\n * @example\n *\n *      var average = R.converge(R.divide, [R.sum, R.length])\n *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4\n *\n *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])\n *      strangeConcat(\"Yodel\") //=> \"YODELyodel\"\n *\n * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))\n */\nvar converge = /*#__PURE__*/_curry2(function converge(after, fns) {\n  return curryN(reduce(max, 0, pluck('length', fns)), function () {\n    var args = arguments;\n    var context = this;\n    return after.apply(context, _map(function (fn) {\n      return fn.apply(context, args);\n    }, fns));\n  });\n});\nexport default converge;","import _curryN from './_curryN';\nimport _has from './_has';\nimport _xfBase from './_xfBase';\n\nvar XReduceBy = /*#__PURE__*/function () {\n  function XReduceBy(valueFn, valueAcc, keyFn, xf) {\n    this.valueFn = valueFn;\n    this.valueAcc = valueAcc;\n    this.keyFn = keyFn;\n    this.xf = xf;\n    this.inputs = {};\n  }\n  XReduceBy.prototype['@@transducer/init'] = _xfBase.init;\n  XReduceBy.prototype['@@transducer/result'] = function (result) {\n    var key;\n    for (key in this.inputs) {\n      if (_has(key, this.inputs)) {\n        result = this.xf['@@transducer/step'](result, this.inputs[key]);\n        if (result['@@transducer/reduced']) {\n          result = result['@@transducer/value'];\n          break;\n        }\n      }\n    }\n    this.inputs = null;\n    return this.xf['@@transducer/result'](result);\n  };\n  XReduceBy.prototype['@@transducer/step'] = function (result, input) {\n    var key = this.keyFn(input);\n    this.inputs[key] = this.inputs[key] || [key, this.valueAcc];\n    this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);\n    return result;\n  };\n\n  return XReduceBy;\n}();\n\nvar _xreduceBy = /*#__PURE__*/_curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {\n  return new XReduceBy(valueFn, valueAcc, keyFn, xf);\n});\nexport default _xreduceBy;","import _curryN from './internal/_curryN';\nimport _dispatchable from './internal/_dispatchable';\nimport _has from './internal/_has';\nimport _reduce from './internal/_reduce';\nimport _xreduceBy from './internal/_xreduceBy';\n\n/**\n * Groups the elements of the list according to the result of calling\n * the String-returning function `keyFn` on each element and reduces the elements\n * of each group to a single value via the reducer function `valueFn`.\n *\n * This function is basically a more general [`groupBy`](#groupBy) function.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * @func\n * @memberOf R\n * @since v0.20.0\n * @category List\n * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}\n * @param {Function} valueFn The function that reduces the elements of each group to a single\n *        value. Receives two values, accumulator for a particular group and the current element.\n * @param {*} acc The (initial) accumulator value for each group.\n * @param {Function} keyFn The function that maps the list's element into a key.\n * @param {Array} list The array to group.\n * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of\n *         `valueFn` for elements which produced that key when passed to `keyFn`.\n * @see R.groupBy, R.reduce\n * @example\n *\n *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);\n *      var namesByGrade = reduceToNamesBy(function(student) {\n *        var score = student.score;\n *        return score < 65 ? 'F' :\n *               score < 70 ? 'D' :\n *               score < 80 ? 'C' :\n *               score < 90 ? 'B' : 'A';\n *      });\n *      var students = [{name: 'Lucy', score: 92},\n *                      {name: 'Drew', score: 85},\n *                      // ...\n *                      {name: 'Bart', score: 62}];\n *      namesByGrade(students);\n *      // {\n *      //   'A': ['Lucy'],\n *      //   'B': ['Drew']\n *      //   // ...,\n *      //   'F': ['Bart']\n *      // }\n */\nvar reduceBy = /*#__PURE__*/_curryN(4, [], /*#__PURE__*/_dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {\n  return _reduce(function (acc, elt) {\n    var key = keyFn(elt);\n    acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);\n    return acc;\n  }, {}, list);\n}));\nexport default reduceBy;","import _curry2 from './_curry2';\nimport _xfBase from './_xfBase';\n\nvar XDropRepeatsWith = /*#__PURE__*/function () {\n  function XDropRepeatsWith(pred, xf) {\n    this.xf = xf;\n    this.pred = pred;\n    this.lastValue = undefined;\n    this.seenFirstValue = false;\n  }\n\n  XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;\n  XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;\n  XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {\n    var sameAsLast = false;\n    if (!this.seenFirstValue) {\n      this.seenFirstValue = true;\n    } else if (this.pred(this.lastValue, input)) {\n      sameAsLast = true;\n    }\n    this.lastValue = input;\n    return sameAsLast ? result : this.xf['@@transducer/step'](result, input);\n  };\n\n  return XDropRepeatsWith;\n}();\n\nvar _xdropRepeatsWith = /*#__PURE__*/_curry2(function _xdropRepeatsWith(pred, xf) {\n  return new XDropRepeatsWith(pred, xf);\n});\nexport default _xdropRepeatsWith;","import _curry2 from './internal/_curry2';\nimport _isString from './internal/_isString';\n\n/**\n * Returns the nth element of the given list or string. If n is negative the\n * element at index length + n is returned.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category List\n * @sig Number -> [a] -> a | Undefined\n * @sig Number -> String -> String\n * @param {Number} offset\n * @param {*} list\n * @return {*}\n * @example\n *\n *      var list = ['foo', 'bar', 'baz', 'quux'];\n *      R.nth(1, list); //=> 'bar'\n *      R.nth(-1, list); //=> 'quux'\n *      R.nth(-99, list); //=> undefined\n *\n *      R.nth(2, 'abc'); //=> 'c'\n *      R.nth(3, 'abc'); //=> ''\n * @symb R.nth(-1, [a, b, c]) = c\n * @symb R.nth(0, [a, b, c]) = a\n * @symb R.nth(1, [a, b, c]) = b\n */\nvar nth = /*#__PURE__*/_curry2(function nth(offset, list) {\n  var idx = offset < 0 ? list.length + offset : offset;\n  return _isString(list) ? list.charAt(idx) : list[idx];\n});\nexport default nth;","import _curry2 from './internal/_curry2';\nimport _dispatchable from './internal/_dispatchable';\nimport _xdropRepeatsWith from './internal/_xdropRepeatsWith';\nimport last from './last';\n\n/**\n * Returns a new list without any consecutively repeating elements. Equality is\n * determined by applying the supplied predicate to each pair of consecutive elements. The\n * first element in a series of equal elements will be preserved.\n *\n * Acts as a transducer if a transformer is given in list position.\n *\n * @func\n * @memberOf R\n * @since v0.14.0\n * @category List\n * @sig ((a, a) -> Boolean) -> [a] -> [a]\n * @param {Function} pred A predicate used to test whether two items are equal.\n * @param {Array} list The array to consider.\n * @return {Array} `list` without repeating elements.\n * @see R.transduce\n * @example\n *\n *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];\n *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]\n */\nvar dropRepeatsWith = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {\n  var result = [];\n  var idx = 1;\n  var len = list.length;\n  if (len !== 0) {\n    result[0] = list[0];\n    while (idx < len) {\n      if (!pred(last(result), list[idx])) {\n        result[result.length] = list[idx];\n      }\n      idx += 1;\n    }\n  }\n  return result;\n}));\nexport default dropRepeatsWith;","import _curry1 from './internal/_curry1';\nimport curryN from './curryN';\n\n/**\n * Returns a new function much like the supplied one, except that the first two\n * arguments' order is reversed.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)\n * @param {Function} fn The function to invoke with its first two parameters reversed.\n * @return {*} The result of invoking `fn` with its first two parameters' order reversed.\n * @example\n *\n *      var mergeThree = (a, b, c) => [].concat(a, b, c);\n *\n *      mergeThree(1, 2, 3); //=> [1, 2, 3]\n *\n *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]\n * @symb R.flip(f)(a, b, c) = f(b, a, c)\n */\nvar flip = /*#__PURE__*/_curry1(function flip(fn) {\n  return curryN(fn.length, function (a, b) {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args[0] = b;\n    args[1] = a;\n    return fn.apply(this, args);\n  });\n});\nexport default flip;","import _curry2 from './internal/_curry2';\nimport _isFunction from './internal/_isFunction';\nimport curryN from './curryN';\nimport toString from './toString';\n\n/**\n * Turns a named method with a specified arity into a function that can be\n * called directly supplied with arguments and a target object.\n *\n * The returned function is curried and accepts `arity + 1` parameters where\n * the final parameter is the target object.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Function\n * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)\n * @param {Number} arity Number of arguments the returned function should take\n *        before the target object.\n * @param {String} method Name of the method to call.\n * @return {Function} A new curried function.\n * @see R.construct\n * @example\n *\n *      var sliceFrom = R.invoker(1, 'slice');\n *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'\n *      var sliceFrom6 = R.invoker(2, 'slice')(6);\n *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'\n * @symb R.invoker(0, 'method')(o) = o['method']()\n * @symb R.invoker(1, 'method')(a, o) = o['method'](a)\n * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)\n */\nvar invoker = /*#__PURE__*/_curry2(function invoker(arity, method) {\n  return curryN(arity + 1, function () {\n    var target = arguments[arity];\n    if (target != null && _isFunction(target[method])) {\n      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));\n    }\n    throw new TypeError(toString(target) + ' does not have a method named \"' + method + '\"');\n  });\n});\nexport default invoker;","export default function _isFunction(x) {\n  return Object.prototype.toString.call(x) === '[object Function]';\n}","import _curry1 from './internal/_curry1';\nimport converge from './converge';\n\n/**\n * juxt applies a list of functions to a list of values.\n *\n * @func\n * @memberOf R\n * @since v0.19.0\n * @category Function\n * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])\n * @param {Array} fns An array of functions\n * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.\n * @see R.applySpec\n * @example\n *\n *      var getRange = R.juxt([Math.min, Math.max]);\n *      getRange(3, 4, 9, -3); //=> [-3, 9]\n * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]\n */\nvar juxt = /*#__PURE__*/_curry1(function juxt(fns) {\n  return converge(function () {\n    return Array.prototype.slice.call(arguments, 0);\n  }, fns);\n});\nexport default juxt;","import _curry2 from './internal/_curry2';\n\n/**\n * Multiplies two numbers. Equivalent to `a * b` but curried.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Math\n * @sig Number -> Number -> Number\n * @param {Number} a The first value.\n * @param {Number} b The second value.\n * @return {Number} The result of `a * b`.\n * @see R.divide\n * @example\n *\n *      var double = R.multiply(2);\n *      var triple = R.multiply(3);\n *      double(3);       //=>  6\n *      triple(4);       //=> 12\n *      R.multiply(2, 5);  //=> 10\n */\nvar multiply = /*#__PURE__*/_curry2(function multiply(a, b) {\n  return a * b;\n});\nexport default multiply;","import _curry2 from './internal/_curry2';\n\n/**\n * Similar to `pick` except that this one includes a `key: undefined` pair for\n * properties that don't exist.\n *\n * @func\n * @memberOf R\n * @since v0.1.0\n * @category Object\n * @sig [k] -> {k: v} -> {k: v}\n * @param {Array} names an array of String property names to copy onto a new object\n * @param {Object} obj The object to copy from\n * @return {Object} A new object with only properties from `names` on it.\n * @see R.pick\n * @example\n *\n *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}\n *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}\n */\nvar pickAll = /*#__PURE__*/_curry2(function pickAll(names, obj) {\n  var result = {};\n  var idx = 0;\n  var len = names.length;\n  while (idx < len) {\n    var name = names[idx];\n    result[name] = obj[name];\n    idx += 1;\n  }\n  return result;\n});\nexport default pickAll;","import _concat from './internal/_concat';\nimport _createPartialApplicator from './internal/_createPartialApplicator';\nimport flip from './flip';\n\n/**\n * Takes a function `f` and a list of arguments, and returns a function `g`.\n * When applied, `g` returns the result of applying `f` to the arguments\n * provided to `g` followed by the arguments provided initially.\n *\n * @func\n * @memberOf R\n * @since v0.10.0\n * @category Function\n * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)\n * @param {Function} f\n * @param {Array} args\n * @return {Function}\n * @see R.partial\n * @example\n *\n *      var greet = (salutation, title, firstName, lastName) =>\n *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';\n *\n *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);\n *\n *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'\n * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)\n */\nvar partialRight = /*#__PURE__*/_createPartialApplicator( /*#__PURE__*/flip(_concat));\nexport default partialRight;","import _curry1 from './internal/_curry1';\n\nvar ws = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' + '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' + '\\u2029\\uFEFF';\nvar zeroWidth = '\\u200b';\nvar hasProtoTrim = typeof String.prototype.trim === 'function';\n/**\n * Removes (strips) whitespace from both ends of the string.\n *\n * @func\n * @memberOf R\n * @since v0.6.0\n * @category String\n * @sig String -> String\n * @param {String} str The string to trim.\n * @return {String} Trimmed version of `str`.\n * @example\n *\n *      R.trim('   xyz  '); //=> 'xyz'\n *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']\n */\nvar _trim = !hasProtoTrim || /*#__PURE__*/ws.trim() || ! /*#__PURE__*/zeroWidth.trim() ? function trim(str) {\n  var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');\n  var endRx = new RegExp('[' + ws + '][' + ws + ']*$');\n  return str.replace(beginRx, '').replace(endRx, '');\n} : function trim(str) {\n  return str.trim();\n};\nvar trim = /*#__PURE__*/_curry1(_trim);\nexport default trim;","\nimport {throwError as observableThrowError,  Observable ,  of ,  Observer } from 'rxjs';\nimport { isNil as isNilR } from 'ramda';\n\n/**\n * return json string from json-like string\n */\nexport function jsonize(str: string): string {\n  try {       // if parsable already, return as it is\n    JSON.parse(str);\n    return str;\n  } catch (e) { // if not parsable, change little\n    return str\n      .replace(/([\\$\\w]+)\\s*:/g, // wrap keys without double quote\n        function(_: any, $1: any) {\n          return '\"' + $1 + '\":';\n        }\n      )\n      .replace(/'([^']+)'/g,   // replacing single quote to double quote\n        function(_: any, $1: any) {\n          return '\"' + $1 + '\"';\n        }\n      );\n  }\n}\n\n/**\n * Returns string to an object by using JSON.parse()\n */\nexport function getJSON(input: any): any {\n  if (typeof input === 'string') {\n    const re = /^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; // lat,lng\n    if (input.match(re)) {\n      input = '[' + input + ']';\n    }\n    return JSON.parse(jsonize(input));\n  } else {\n    return input;\n  }\n}\n\n/**\n * json type definition\n */\n/* tslint:disable */\n//interface IJsonArray extends Array<string|number|boolean|Date|IJson|IJsonArray> { }\nexport interface IJson {\n  //[x: string]: string|number|boolean|Date|IJson|IJsonArray;\n  [x: string]: string|number|boolean|Date|IJson|Array<string|number|boolean|Date|IJson>;\n}\n/* tslint:enable */\n\n\n/**\n * Returns camel-cased from string 'Foo Bar' to 'fooBar'\n *\n * @param str string to convert\n */\nexport function toCamelCase(str: string): string {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function(letter, index) {\n    return index === 0 ? letter.toLowerCase() : letter.toUpperCase();\n  }).replace(/\\s+/g, '');\n}\n\n/**\n * Checks if global google.maps object is defined\n */\nexport function isMapsApiLoaded() {\n  return typeof google === 'object' && typeof google.maps === 'object';\n}\n\nexport function missingLibraryError(component, libName) {\n  return Error(`${component}: library '${libName}' is missing, please ensure to include it in a 'libraries' parameter.\n    Example:\n      NguiMapModule.forRoot({\n        apiUrl: 'https://maps.googleapis.com/maps/api/js?libraries=${libName}'\n      })\n  `);\n}\n\n/**\n * Loads script by url\n * @param url Url of script\n * @param scriptId Unique identificator of script - this will add id to script\n *                 element, also will be used to store script load state in window\n *                 object\n * @param window Window object\n * @returns Observable that emits when script is loaded, throws an error in case\n *          it is not possible to determine script load state\n */\nexport const loadScript = (\n    url: string,\n    scriptId: string,\n    window,\n    loadedObjKey = 'loadedScripts'\n): Observable<any> => {\n    if (typeof window === 'undefined') {\n        return observableThrowError(\n            new Error('\"window\" has to be defined to load script')\n        );\n    }\n\n    window[loadedObjKey] = window[loadedObjKey] || {};\n    const storage = window[loadedObjKey];\n\n    if (document.querySelector(`#${scriptId}`)) {\n        const scriptState = storage[scriptId];\n\n        if (isNilR(scriptState)) {\n            observableThrowError(new Error('Can not determine state of script loading'));\n        }\n\n        return of(scriptState);\n    }\n\n    // Set target script as not loaded\n    storage[scriptId] = false;\n\n    return Observable.create((observer: Observer<boolean>) => {\n\n        // #region Creation of script element\n        const script = document.createElement('script');\n        script.id = scriptId;\n        script.async = true;\n        script.src = url;\n        script.type = 'text/javascript';\n        script.onload = () => {\n            storage[scriptId] = true;\n            observer.next(true);\n            observer.complete();\n        };\n        // #endregion\n\n        document.querySelector('body').appendChild(script);\n    });\n};","import {\n    EventEmitter,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    Output,\n    SimpleChanges\n    } from '@angular/core';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { MapService } from '../services/map.service';\nimport { OptionBuilder } from '../services/option-builder';\nimport { missingLibraryError } from '../services/util';\n\nexport abstract class BaseMapDirective implements OnInit, OnChanges, OnDestroy {\n  // this should be redefined on each childr directive\n  @Output() initialized$: EventEmitter<any> = new EventEmitter();\n\n  public mapObject: any; // e.g. google.maps.Marker\n  public objectOptions: any; // e.g. google.maps.MarkerOptions\n\n  public nguiMap: MapService;\n  public optionBuilder: OptionBuilder;\n  public libraryName: string;\n  protected _subscriptions = [];\n\n  constructor(\n    protected nguiMapComponent: NguiMapComponent,\n    public    mapObjectName: string,\n    protected inputs: string[],\n    protected outputs: string[]\n  ) {\n    this.nguiMap = this.nguiMapComponent['nguiMap'];\n    this.optionBuilder = this.nguiMapComponent['optionBuilder'];\n    // all outputs must be initialized\n    this.outputs.forEach(output => this[output] = new EventEmitter());\n    this.mapObjectName = mapObjectName;\n  }\n\n  // Initialize this map object when map is ready\n  ngOnInit() {\n    if (this.nguiMapComponent.mapIdledOnce) { // map is ready already\n      this.initialize();\n    } else {\n      this.nguiMapComponent.mapReady$.subscribe(() => this.initialize());\n    }\n  }\n\n  // only called when map is ready\n  initialize(): void {\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n    // console.log(this.mapObjectName, 'initialization options', this.objectOptions);\n\n    // will be set after geocoded\n    typeof this.objectOptions.position === 'string' && (delete this.objectOptions.position);\n    typeof this.objectOptions.center === 'string' && (delete this.objectOptions.center);\n\n    // noinspection TypeScriptUnresolvedFunction\n    if (this.libraryName) {\n      if (!google.maps[this.libraryName]) {\n        throw missingLibraryError(this.mapObjectName, this.libraryName);\n      }\n      this.mapObject = new google.maps[this.libraryName][this.mapObjectName](this.objectOptions);\n    } else {\n      this.mapObject = new google.maps[this.mapObjectName](this.objectOptions);\n    }\n    this.mapObject.setMap(this.nguiMapComponent.map);\n    this.mapObject['mapObjectName'] = this.mapObjectName;\n    this.mapObject['nguiMapComponent'] = this.nguiMapComponent;\n\n    // set google events listeners and emits to this outputs listeners\n    this.nguiMap.setObjectEvents(this.outputs, this, this.mapObject);\n\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  }\n\n  // When input is changed, update object too.\n  // e.g., when map center is changed by user, update center on the map\n  ngOnChanges(changes: SimpleChanges) {\n    // console.log(this.mapObjectName, 'objectOptions are changed', changes);\n    this.nguiMap.updateGoogleObject(this.mapObject, changes);\n  }\n\n  // When destroyed, remove event listener, and delete this object to prevent memory leak\n  ngOnDestroy() {\n    this._subscriptions.map(subscription => subscription.unsubscribe());\n    this.nguiMapComponent.removeFromMapObjectGroup(this.mapObjectName, this.mapObject);\n\n    if (this.mapObject) {\n      this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      const { lastValue } = this;\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively when scheduled with things like\n      // VirtualScheduler/TestScheduler.\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function defaultIfEmpty<T>(defaultValue?: T): MonoTypeOperatorFunction<T>;\nexport function defaultIfEmpty<T, R>(defaultValue?: R): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n * If no clicks happen in 5 seconds, then emit \"no clicks\"\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R = null): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new DefaultIfEmptyOperator(defaultValue)) as Observable<T | R>;\n}\n\nclass DefaultIfEmptyOperator<T, R> implements Operator<T, T | R> {\n\n  constructor(private defaultValue: R) {\n  }\n\n  call(subscriber: Subscriber<T | R>, source: any): any {\n    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DefaultIfEmptySubscriber<T, R> extends Subscriber<T> {\n  private isEmpty: boolean = true;\n\n  constructor(destination: Subscriber<T | R>, private defaultValue: R) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.isEmpty = false;\n    this.destination.next(value);\n  }\n\n  protected _complete(): void {\n    if (this.isEmpty) {\n      this.destination.next(this.defaultValue);\n    }\n    this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n * Emit only click events whose target was a DIV element\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => ev.target.tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * ![](do.png)\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link Observable#subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","import { tap } from './tap';\nimport { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n * ```javascript\n * const click$ = fromEvent(button, 'click');\n *\n * clicks$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(\n *     () => new Error('the button was not clicked within 1 second')\n *   ),\n * )\n * .subscribe({\n *   next() { console.log('The button was clicked'); },\n *   error(err) { console.error(err); },\n * });\n * ```\n *\n * @param {Function} [errorFactory] A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n */\nexport const throwIfEmpty =\n  <T>(errorFactory: (() => any) = defaultErrorFactory) => tap<T>({\n    hasValue: false,\n    next() { this.hasValue = true; },\n    complete() {\n      if (!this.hasValue) {\n        throw errorFactory();\n      }\n    }\n  } as any);\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```javascript\n * const interval = interval(1000);\n * const five = interval.pipe(take(5));\n * five.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction, OperatorFunction } from '../../internal/types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\n/* tslint:disable:max-line-length */\nexport function first<T>(\n  predicate?: null,\n  defaultValue?: T\n): MonoTypeOperatorFunction<T>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: T\n): OperatorFunction<T, S>;\nexport function first<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: T\n): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * ## Examples\n * Emit only the first click that happens on the DOM\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nexport function first<T>(\n  predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: T\n): MonoTypeOperatorFunction<T> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) => source.pipe(\n    predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n    take(1),\n    hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()),\n  );\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\nimport { FactoryOrValue, MonoTypeOperatorFunction, OperatorFunction, UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function multicast<T>(subjectOrSubjectFactory: FactoryOrValue<Subject<T>>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\nexport function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<R>>;\nexport function multicast<T, R>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector?: OperatorFunction<T, R>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * ![](multicast.png)\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\n    let subjectFactory: () => Subject<T>;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return <Subject<T>>subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n\n    return <ConnectableObservable<R>> connectable;\n  };\n}\n\nexport class MulticastOperator<T, R> implements Operator<T, R> {\n  constructor(private subjectFactory: () => Subject<T>,\n              private selector: (source: Observable<T>) => Observable<R>) {\n  }\n  call(subscriber: Subscriber<R>, source: any): any {\n    const { selector } = this;\n    const subject = this.subjectFactory();\n    const subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  }\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction, MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport function publishReplay<T, R>(bufferSize?: number, windowTime?: number, selector?: OperatorFunction<T, R>, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, selector?: MonoTypeOperatorFunction<T>, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\nexport function publishReplay<T, R>(bufferSize?: number,\n                                    windowTime?: number,\n                                    selectorOrScheduler?: SchedulerLike | OperatorFunction<T, R>,\n                                    scheduler?: SchedulerLike): UnaryFunction<Observable<T>, ConnectableObservable<R>> {\n\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n\n  return (source: Observable<T>) => multicast(() => subject, selector)(source) as ConnectableObservable<R>;\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n * Tick every second until the first click happens\n * ```javascript\n * const interval = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = interval.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeUntilOperator(notifier));\n}\n\nclass TakeUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);\n    const notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);\n    if (notifierSubscription && !notifierSubscription.closed) {\n      takeUntilSubscriber.add(notifierSubscription);\n      return source.subscribe(takeUntilSubscriber);\n    }\n    return takeUntilSubscriber;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeUntilSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  constructor(destination: Subscriber<any>, ) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.complete();\n  }\n\n  notifyComplete(): void {\n    // noop\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n * Every other second, emit the click events from the next 500ms\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : empty()),\n *   mergeAll(),\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport function windowToggle<T, O>(openings: Observable<O>,\n                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));\n}\n\nclass WindowToggleOperator<T, O> implements Operator<T, Observable<T>> {\n\n  constructor(private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowToggleSubscriber(\n      subscriber, this.openings, this.closingSelector\n    ));\n  }\n}\n\ninterface WindowContext<T> {\n  window: Subject<T>;\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> {\n  private contexts: WindowContext<T>[] = [];\n  private openSubscription: Subscription;\n\n  constructor(destination: Subscriber<Observable<T>>,\n              private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n    super(destination);\n    this.add(this.openSubscription = subscribeToResult(this, openings, openings as any));\n  }\n\n  protected _next(value: T) {\n    const { contexts } = this;\n    if (contexts) {\n      const len = contexts.length;\n      for (let i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n\n    const { contexts } = this;\n    this.contexts = null;\n\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n\n    if (outerValue === this.openings) {\n\n      const { closingSelector } = this;\n      const closingNotifier = tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject) {\n        return this.error(errorObject.e);\n      } else {\n        const window = new Subject<T>();\n        const subscription = new Subscription();\n        const context = { window, subscription };\n        this.contexts.push(context);\n        const innerSubscription = subscribeToResult(this, closingNotifier, context as any);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          (<any> innerSubscription).context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window);\n\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  }\n\n  notifyError(err: any): void {\n    this.error(err);\n  }\n\n  notifyComplete(inner: Subscription): void {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf((<any> inner).context));\n    }\n  }\n\n  private closeWindow(index: number): void {\n    if (index === -1) {\n      return;\n    }\n\n    const { contexts } = this;\n    const context = contexts[index];\n    const { window, subscription } = context;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const NG_MAP_CONFIG_TOKEN = new InjectionToken<ConfigOption>('NG_MAP_CONFIG_TOKEN');\nexport interface ConfigOption {\n  apiUrl?: string;\n}\n","import {\n    Inject,\n    Injectable,\n    OnDestroy,\n    Optional\n    } from '@angular/core';\nimport { ReplaySubject } from 'rxjs';\nimport { NG_MAP_CONFIG_TOKEN } from './config';\nimport {\n    isMapsApiLoaded,\n    loadScript\n    } from './util';\n\ntype MapLoadConfig = {\n    apiUrl: string;\n};\n\nexport abstract class NgMapApiLoader implements OnDestroy {\n    api$: ReplaySubject<any> = new ReplaySubject(1);\n\n    private readonly defaultConf = {\n        apiUrl: 'https://maps.google.com/maps/api/js'\n    };\n\n    abstract load(): void;\n\n    constructor(\n        protected config: MapLoadConfig\n    ) {\n        this.config = { ...this.defaultConf, ...this.config};\n    }\n\n    ngOnDestroy() {\n        this.api$.complete();\n    }\n}\n\n// #region Not used anymore\n// @Injectable()\n// export class NgMapAsyncCallbackApiLoader extends NgMapApiLoader {\n//     readonly scriptLoadedCallback: string = 'mapDownloaded';\n//     readonly scriptElementId: string = 'ngui-map-api';\n//     readonly scriptElementSelector: string = `#${this.scriptElementId}`;\n\n//     constructor(\n//         protected _zone: NgZone,\n//         @Optional() @Inject(NG_MAP_CONFIG_TOKEN) config\n//     ) {\n//         super(config);\n//     }\n\n//     load() {\n//         if (typeof window === 'undefined') {\n//             return;\n//         }\n\n//         if (isMapsApiLoaded()) {\n//             this.api$.next(google.maps);\n//             return;\n//         }\n\n//         if (!document.querySelector(this.scriptElementSelector)) {\n//             (<any>window)['nguiMapRef'] = (<any>window)['nguiMapRef'] || [];\n//             (<any>window)['nguiMapRef'].push({\n//                 zone: this._zone,\n//                 provideApiCallback: () => this.api$.next(google.maps)\n//             });\n//             this.addGoogleMapsApi();\n//         }\n//     }\n\n//     private addGoogleMapsApi() {\n//         (<any>window)[this.scriptLoadedCallback] =\n//             (<any>window)[this.scriptLoadedCallback] ||\n//                 function() {\n//                     (<any>window)['nguiMapRef'].forEach(nguiMapRef => {\n//                         nguiMapRef.zone.run(function() {\n//                             nguiMapRef.provideApiCallback();\n//                         });\n//                     });\n//                     (<any>window)['nguiMapRef'].splice(\n//                         0,\n//                         (<any>window)['nguiMapRef'].length\n//                     );\n//                 };\n\n//         const script = document.createElement('script');\n\n//         let apiUrl = this.config.apiUrl;\n//         apiUrl += apiUrl.indexOf('?') !== -1 ? '&' : '?';\n//         script.src = `${apiUrl}callback=${this.scriptLoadedCallback}`;\n//         document.querySelector('body').appendChild(script);\n//     }\n// }\n// #endregion\n\n@Injectable()\nexport class NgMapAsyncApiLoader extends NgMapApiLoader {\n    readonly scriptId = 'googleMaps';\n\n    constructor(\n        @Optional() @Inject(NG_MAP_CONFIG_TOKEN) config\n    ) {\n        super(config);\n    }\n\n    load() {\n        if (isMapsApiLoaded()) {\n            this.apiLoaded();\n        }\n\n        return loadScript(this.config.apiUrl, this.scriptId, window)\n            .subscribe((loaded: boolean) => {\n                if (loaded) this.apiLoaded();\n            });\n    }\n\n    private apiLoaded() {\n        this.api$.next(google.maps);\n    }\n}\n","import { Injectable, OnDestroy } from '@angular/core';\nimport { Observable ,  Observer } from 'rxjs';\nimport { NgMapApiLoader } from './api-loader';\n\n/**\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *   service for Google Geocoder service\n */\n\n@Injectable()\nexport class GeoCoder implements OnDestroy {\n  private apiLoaderSubs = [];\n  constructor(private apiLoader: NgMapApiLoader) {}\n\n  geocode(options: google.maps.GeocoderRequest) {\n    return new Observable((responseObserver: Observer<any>) => {\n        this.apiLoaderSubs.push(this.apiLoader.api$\n          .subscribe(() => this.requestGeocode(options, responseObserver)));\n    });\n  }\n\n  ngOnDestroy() {\n    this.apiLoaderSubs.map(sub => sub.unsubscribe());\n  }\n\n  private requestGeocode(options, observer) {\n    const geocoder = new google.maps.Geocoder();\n    geocoder.geocode(options, function (results, status) {\n      if (status === google.maps.GeocoderStatus.OK) {\n        observer.next(results);\n        observer.complete();\n      } else {\n        observer.error(results);\n      }\n    });\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { BehaviorSubject ,  Observable } from 'rxjs';\n\n@Injectable()\nexport class MapLoadedService {\n    loaded$: Observable<boolean>;\n    private readonly _loaded$: BehaviorSubject<boolean>;\n\n    constructor() {\n        this._loaded$ = new BehaviorSubject(false);\n        this.loaded$ = this._loaded$.asObservable();\n    }\n\n    isLoaded = (): boolean => {\n        return this._loaded$.value;\n    }\n\n    loaded = (loaded: boolean = true) => {\n        this._loaded$.next(loaded);\n    }\n}","import { Injectable } from '@angular/core';\nimport {\n    getJSON,\n    IJson\n    } from './util';\n\n/**\n * change any object to google object options\n * e.g. [1,2] -> new google.maps.LatLng(1,2);\n */\n@Injectable()\nexport class OptionBuilder {\n\n  googlizeAllInputs(definedInputs: string[], userInputs: any) {\n    let options: any = {};\n\n    // if options given from user, only take options and ignore other inputs\n    if (userInputs.options) {\n      console.log('userInputs.options .................', userInputs.options);\n      options = userInputs.options;\n      if (!this.onlyOptionsGiven(definedInputs, userInputs)) {\n        console.error('when \"options\" are used, other options are ignored');\n      }\n    } else { // if options not given, process all user inputs\n      definedInputs.forEach(input => {\n        if (userInputs[input] !== undefined)  {\n          options[input] = this.googlize(userInputs[input], {key: input});\n        }\n      });\n    }\n    return options;\n  }\n\n  googlizeMultiple(inputs: any[], options?: IJson): any {\n    options =  options || {};\n    for (let key in inputs) {\n      let val = inputs[key];\n      // (non-strings are fully converted)\n      if (typeof val !== 'string') {\n        options[key] = val;\n      } // sometimes '0' needed to stay as it is\n      else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {\n        options[key] = this.googlize(val, {key: key});\n      }\n    } // for(var key in attrs)\n    return options;\n  }\n\n  googlize(input: any, options?: IJson): any {\n    options = options || {};\n    let output: any = input;\n    if (typeof input === 'string') { // convert string to a google object\n      if (input === 'false') {\n        output = false;\n      } else if (input === '0') {\n        output = 0;\n      } else {\n        output =\n          // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed\n          this.getJSONParsed(input, options)\n\n          /* Foo.Bar(...) -> new google.maps.Foo.Bar(...) */\n          || this.getAnyMapObject(input)\n\n          /*  MapTypeID.HYBRID -> new google.maps.MapTypeID.HYBRID */\n          || this.getAnyMapConstant(input, options)\n\n          /*  2016-06-20 -> new Date('2016-06-20') */\n          || this.getDateObject(input)\n\n          || input;\n      }\n    }\n\n    if (options['key']) {\n      let key: string = <string>options['key'];\n      if (output instanceof Array) { // e.g., [1, 2]\n        if (key === 'bounds') {\n          output = new google.maps.LatLngBounds(output[0], output[1]);\n        } else if (key === 'icons') {\n          output = this.getMapIcons(output);\n        } else if (key === 'position' || key.match(/^geoFallback/) ) {\n          output = this.getLatLng(output);\n        }\n      } else if (output instanceof Object) {\n        if (key === 'icon') {\n          output = this.getMarkerIcon(output);\n        }\n        else if (key.match(/ControlOptions$/)) {\n          output = this.getMapControlOption(output);\n        }\n      }\n    }\n\n    // delete keys only for processing, not used by google\n    delete output['doNotConverStringToNumber'];\n    delete output['key'];\n\n    return output;\n  }\n\n  private getLatLng(input: any): google.maps.LatLng | Array<google.maps.LatLng> {\n    let output: google.maps.LatLng | Array<google.maps.LatLng>;\n    if (input[0].constructor === Array) { // [[1,2],[3,4]]\n      output = (<any[]>input).map((el: number[]) => new google.maps.LatLng(el[0], el[1]));\n    } else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n      output = new google.maps.LatLng(input[0], input[1]);\n    }\n    return output;\n  }\n\n  private getJSONParsed(input: any, options: IJson): IJson {\n    let output: any;\n    try {\n      output = getJSON(input);\n      if (output instanceof Array) {\n        // [{a:1}] : not lat/lng ones\n\n        if (output[0].constructor !== Object) { // [[1,2],[3,4]] or [1,2]\n          output = this.getLatLng(output);\n        }\n      }\n      // JSON is an object (not array or null)\n      else if (output === Object(output)) {\n        // check for nested hashes and convert to Google API options\n        let newOptions = options;\n        newOptions['doNotConverStringToNumber'] = true;\n        output = this.googlizeMultiple(output, newOptions);\n      }\n    } catch (e) {\n    }\n    return output;\n  }\n\n  private getAnyMapObject(input: string): any {\n    let output: any;\n    if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n      try {\n        output = Function(`return new google.maps.${input};`)();\n      } catch (e) {}\n    }\n    return output;\n  }\n\n  private getAnyMapConstant(input: string, options: IJson): any {\n    let output: any;\n\n    if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) { // e.g. MapTypeID.HYBRID\n      try {\n        let matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n        output = google.maps[matches[1]][matches[2]];\n      } catch (e) {}\n    } else if (input.match(/^[A-Z]+$/)) { // e.g. HYBRID\n      try {\n        let capitalizedKey = (<string>options['key']).charAt(0).toUpperCase() +\n          (<string>options['key']).slice(1);\n        output = google.maps[capitalizedKey][input];\n      } catch (e) {}\n    }\n    return output;\n  }\n\n  /**\n   * streetviewControl, panControl, etc, not a general control\n   */\n  private getMapControlOption(controlOptions: IJson): IJson {\n    let newControlOptions: IJson = controlOptions;\n\n    for (let key in newControlOptions) { // assign the right values\n      if (newControlOptions[key]) {\n        let value = newControlOptions[key];\n\n        if (typeof value === 'string') {\n          value = (<string>value).toUpperCase();\n        }\n        else if (key === 'mapTypeIds') {\n          value = (<any[]>value).map(function (str) {\n            if (str.match(/^[A-Z]+$/)) { // if constant\n              return google.maps.MapTypeId[str.toUpperCase()];\n            } else { // else, custom map-type\n              return str;\n            }\n          });\n        }\n\n        if (key === 'style') {\n          let objName = key.replace(/Options$/, '') + 'Style';\n          newControlOptions[key] = google.maps[objName][<any>value];\n        }\n        else if (key === 'position') {\n          newControlOptions[key] = google.maps.ControlPosition[<any>value];\n        }\n        else {\n          newControlOptions[key] = value;\n        }\n      }\n    }\n\n    return newControlOptions;\n  }\n\n  private getDateObject(input: string): Date {\n    let output: Date;\n\n    if (input.match(/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/)) {\n      try {\n        output = new Date(input);\n      } catch (e) {}\n    }\n    return output;\n  }\n\n  private getMapIcons(input: any[]): any[] {\n    return input.map(el => {\n      if (el.icon.path.match(/^[A-Z_]+$/)) {\n        el.icon.path = google.maps.SymbolPath[el.icon.path];\n      }\n      return el;\n    });\n  }\n\n  private getMarkerIcon(input: any): any {\n    let output = {...input};\n\n    // if (('' + output.path).match(/^[A-Z_]+$/)) {\n    //   output.path = google.maps.SymbolPath[output.path];\n    // }\n\n    // for (let key in output) {\n    //   let arr = output[key];\n    //   if (key === 'anchor' || key === 'origin' || key === 'labelOrigin') {\n    //     output[key] = new google.maps.Point(arr[0], arr[1]);\n    // } else if (key === 'size' || key === 'scaledSize') {\n    //     output[key] = new google.maps.Size(arr[0], arr[1]);\n    //   }\n    // }\n\n    return output;\n  }\n\n  private onlyOptionsGiven(definedInputs: string[], userInputs: any): boolean {\n    for (let i = 0; i < definedInputs.length; i++) {\n      let input = definedInputs[i];\n      if (input !== 'options' && typeof userInputs[input] !== 'undefined') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","import {\n    Injectable,\n    NgZone,\n    SimpleChanges\n    } from '@angular/core';\nimport { GeoCoder } from './geo-coder';\nimport { OptionBuilder } from './option-builder';\n\n/**\n * collection of map instance-related properties and methods\n */\n@Injectable()\nexport class MapService {\n    constructor(\n        private geoCoder: GeoCoder,\n        private optionBuilder: OptionBuilder,\n        private zone: NgZone\n    ) { }\n\n    /**\n     * Listens for map object events and calls respective emit component methods\n     * @param definedEvents List of events that map object supports\n     * @param componentInstance Instance of Angular component\n     * @param mapObject Map object that is compatible with Google Maps\n     */\n    setObjectEvents(\n        definedEvents: string[],\n        componentInstance: any,\n        mapObject: {\n            addListener(\n                eventName: string,\n                callback: (event: google.maps.event) => void\n            ): void\n        }\n    ) {\n        definedEvents.forEach((definedEvent: string) => {\n            const eventName = this.normalizeEventName(definedEvent);\n            const zone = this.zone;\n\n            zone.runOutsideAngular(() => {\n                mapObject.addListener(\n                    eventName,\n                    function(event: google.maps.event) {\n                        let param: any = event ? event : {};\n                        // param.target = this;\n                        zone.run(\n                            () => componentInstance[definedEvent].emit(param)\n                        );\n                    });\n            });\n        });\n    }\n\n    clearObjectEvents(definedEvents: string[], thisObj: any, prefix: string) {\n        definedEvents.forEach(definedEvent => {\n            const eventName = this.normalizeEventName(definedEvent);\n\n            this.zone.runOutsideAngular(() => {\n                if (thisObj[prefix]) {\n                    google.maps.event.clearListeners(thisObj[prefix], eventName);\n                }\n            });\n        });\n\n        if (thisObj[prefix]) {\n            if (thisObj[prefix].setMap) {\n                thisObj[prefix].setMap(null);\n            }\n\n            delete thisObj[prefix].nguiMapComponent;\n            delete thisObj[prefix];\n        }\n    }\n\n  updateGoogleObject = (object: any, changes: SimpleChanges) => {\n    let val: any, currentValue: any, setMethodName: string;\n    if (object) {\n      for (let key in changes) {\n        setMethodName = `set${key.replace(/^[a-z]/, x => x.toUpperCase())}`;\n        currentValue = changes[key].currentValue;\n        if (\n          ['position', 'center'].indexOf(key) !== -1 &&\n          typeof currentValue === 'string'\n        ) {\n          // To preserve setMethod name in Observable callback, wrap it as a function, then execute\n          (setMethodName => {\n            this.geoCoder\n              .geocode({ address: currentValue })\n              .subscribe(results => {\n                if (typeof object[setMethodName] === 'function') {\n                  object[setMethodName](results[0].geometry.location);\n                } else {\n                  console.error(\n                    'Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' +\n                      'Please check Google Maps API documentation, and use \"setOptions\" instead.'\n                  );\n                }\n              });\n          })(setMethodName);\n        } else {\n          val = this.optionBuilder.googlize(currentValue);\n          if (typeof object[setMethodName] === 'function') {\n            object[setMethodName](val);\n          } else {\n            console.error(\n              'Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' +\n                'Please check Google Maps API documentation, and use \"setOptions\" instead.'\n            );\n          }\n        }\n      }\n    }\n  }\n\n    private normalizeEventName(definedEvent: string): string {\n        return definedEvent\n            // positionChanged -> position_changed\n            .replace(/([A-Z])/g, $1 => `_${$1.toLowerCase()}`)\n            .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport {\n    map,\n    publishReplay,\n    refCount\n    } from 'rxjs/operators';\nimport { loadScript } from '../services/util';\n\n@Injectable()\nexport class MarkerClustererProviderService {\n    private MarkerClusterer$: Observable<typeof MarkerClusterer>;\n\n    // Docs here: http://htmlpreview.github.io/?https://github.com/googlemaps/v3-utility-library/blob/master/markerclustererplus/docs/reference.html\n    private clustererLibUrl = 'https://cdnjs.cloudflare.com/ajax/libs/markerclustererplus/2.1.4/markerclusterer.min.js';\n\n    getClusterer(): Observable<typeof MarkerClusterer> {\n        if (!this.MarkerClusterer$) {\n            this.MarkerClusterer$ = loadScript(\n                this.clustererLibUrl,\n                'marker-clusterer',\n                window)\n            .pipe(\n                map(() => MarkerClusterer),\n                publishReplay(1),\n                refCount()\n            );\n        }\n\n        return this.MarkerClusterer$;\n    }\n}","import { Injectable } from '@angular/core';\nimport { Observable ,  Observer } from 'rxjs';\nimport { IJson } from './util';\n\n/**\n *  service for navigator.geolocation methods\n */\n@Injectable()\nexport class NavigatorGeolocation {\n\n  getCurrentPosition(geoLocationOptions?: IJson): Observable<any> {\n    geoLocationOptions = geoLocationOptions || { timeout: 5000 };\n\n    return new Observable<any>((responseObserver: Observer<any>) => {\n      if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(\n          (position) => {\n            responseObserver.next(position);\n            responseObserver.complete();\n          },\n          (evt) => responseObserver.error(evt),\n          geoLocationOptions\n        );\n      } else {\n        responseObserver.error('Browser Geolocation service failed.');\n      }\n    });\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Observable ,  ReplaySubject } from 'rxjs';\nimport {\n    filter,\n    first\n    } from 'rxjs/operators';\nimport { MapLoadedService } from '../../../services/map-loaded.service';\nimport { CustomMarkerOverlayView } from '../mixins/custom-marker-overlay-view.mixin';\n\n@Injectable()\nexport class CustomMarkerOverlayViewService {\n    CustomMarkerOverlayView;\n\n    overlayDefined$: Observable<boolean>;\n\n    constructor(\n        readonly _mapLoadedService: MapLoadedService\n    ) {\n        const _overlayDefined$ = new ReplaySubject<boolean>();\n        this.overlayDefined$ = _overlayDefined$.asObservable();\n\n        _mapLoadedService.loaded$\n            .pipe(\n                filter(Boolean),\n                first())\n            .subscribe(() => {\n                this.CustomMarkerOverlayView = CustomMarkerOverlayView(\n                    google.maps.OverlayView\n                );\n                _overlayDefined$.next(true);\n            });\n    }\n}","type Constructor<T> = new(...args: any[]) => T;\n\nexport function CustomMarkerOverlayView<\n    TClass extends Constructor<google.maps.OverlayView>\n>(OverlayView: TClass) {\n    return class extends OverlayView {\n        _draggable: boolean;\n        _htmlElement: HTMLElement;\n        _map: google.maps.Map;\n        _position: google.maps.LatLng;\n        _zIndex: string;\n        _dragOrigin: MouseEvent;\n        _mouseLeaveMapListener: google.maps.MapsEventListener;\n        _mouseDownListerer: google.maps.MapsEventListener;\n        _mouseUpListener: google.maps.MapsEventListener;\n        _moveHandler: google.maps.MapsEventListener;\n\n        get mapElement(): Element {\n            const map = this._map;\n            return map instanceof google.maps.Map && map.getDiv();\n        }\n\n        /**\n         * @param args First ramameter is HTMLElement, second is\n         * { lat: number, lng: number } or google.maps.LatLng, third is draggable\n         */\n        constructor(...args: any[]) {\n            super();\n\n            this._htmlElement = args[0];\n            this._draggable = args[2] || false;\n\n            const position = args[1];\n            this._position = position instanceof google.maps.LatLng\n                ? position\n                : new google.maps.LatLng(+position.lat, +position.lng);\n        }\n\n        onAdd(): void {\n            this.getPanes().overlayMouseTarget.appendChild(this._htmlElement);\n            this._htmlElement.style.position = 'absolute';\n        }\n\n        draw(): void {\n            this.setPosition(this._position);\n            this.setZIndex(this._zIndex);\n            this.setVisible(true);\n        }\n\n        onRemove(): void {\n            google.maps.event.clearInstanceListeners(this._htmlElement);\n\n            if (this._draggable) {\n                this._mouseLeaveMapListener.remove();\n            }\n\n            if (this._htmlElement.parentElement) {\n                this._htmlElement.parentElement.removeChild(this._htmlElement);\n            }\n        }\n\n        getPosition() {\n            return this._position;\n        }\n\n        setMap(map: google.maps.Map) {\n            this._map = map;\n            super.setMap(map);\n\n            if (this._map && this._draggable) {\n                this._initDraggable();\n            }\n        }\n\n        setPosition = (position: google.maps.LatLng) => {\n            this._position = position;\n            const projection = this.getProjection();\n\n            if (projection) {\n                let posPixel = projection.fromLatLngToDivPixel(this._position);\n                this._htmlElement.style.left = Math.round(posPixel.x) + 'px';\n                this._htmlElement.style.top = Math.round(posPixel.y) + 'px';\n            }\n        }\n\n        setZIndex(zIndex: string): void {\n            zIndex && (this._zIndex = zIndex);\n            this._htmlElement.style.zIndex = this._zIndex;\n        }\n\n        setVisible(visible: boolean) {\n            this._htmlElement.style.display = visible ? 'inline-block' : 'none';\n        }\n\n        setDraggable(draggable: boolean) {\n            if (this._draggable === draggable) {\n                return;\n            }\n\n            this._draggable = draggable;\n\n            if (draggable) {\n                this._initDraggable();\n                return;\n            }\n\n            this._disposeDragEvents();\n        }\n\n        getDraggable() {\n            return this._draggable;\n        }\n\n        _disposeDragEvents() {\n            if (this._mouseDownListerer) {\n                this._mouseDownListerer.remove();\n            }\n\n            if (this._mouseUpListener) {\n                this._mouseUpListener.remove();\n            }\n\n            if (this._moveHandler) {\n                this._moveHandler.remove();\n            }\n        }\n\n        _initDraggable() {\n            const addDomListener = google.maps.event.addDomListener;\n\n            this._htmlElement.draggable = true;\n\n            this._mouseLeaveMapListener = addDomListener(\n                this.mapElement,\n                'mouseleave',\n                () => this._dragOrigin && this._onDragEnd()\n            );\n\n            // TODO: check if we can use event as parameter\n            this._mouseDownListerer = addDomListener(\n                this._htmlElement,\n                'mousedown',\n                (event: MouseEvent) => {\n                    this._map.set('draggable', false);\n                    this._dragOrigin = event;\n\n                    this._moveHandler = addDomListener(\n                        this.mapElement,\n                        'mousemove',\n                        (event: MouseEvent) => {\n                            const origin = this._dragOrigin;\n\n                            if (!origin) {\n                                return;\n                            }\n\n                            const leftOffset = origin.clientX - event.clientX;\n                            const topOffset = origin.clientY - event.clientY;\n                            const currentPositionPx = this.getProjection()\n                                .fromLatLngToDivPixel(this._position);\n\n                            const nextLatLng = this.getProjection()\n                                .fromDivPixelToLatLng(\n                                    new google.maps.Point(\n                                        Math.round(currentPositionPx.x - leftOffset),\n                                        Math.round(currentPositionPx.y - topOffset)\n                                    )\n                                );\n\n                            this._dragOrigin = event;\n                            this._position = nextLatLng;\n                            this.draw();\n                        }\n                    );\n                }\n            );\n\n            this._mouseUpListener = addDomListener(\n                this._htmlElement,\n                'mouseup',\n                () => this._dragOrigin && this._onDragEnd()\n            );\n        }\n\n        _onDragEnd() {\n            this._map.set('draggable', true);\n            this._dragOrigin = null;\n            this._moveHandler.remove();\n            google.maps.event.trigger(\n                this,\n                'dragend',\n                this._position\n            );\n        }\n    };\n}","import {\n    AfterViewChecked,\n    AfterViewInit,\n    Component,\n    ElementRef,\n    EventEmitter,\n    NgZone,\n    OnChanges,\n    OnDestroy,\n    Output,\n    SimpleChanges,\n    ViewEncapsulation\n    } from '@angular/core';\nimport { debounceTime } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport { NgMapApiLoader } from '../services/api-loader';\nimport { GeoCoder } from '../services/geo-coder';\nimport { MapLoadedService } from '../services/map-loaded.service';\nimport { MapService } from '../services/map.service';\nimport { MarkerClustererProviderService } from '../services/marker-clusterer-provider.service';\nimport { NavigatorGeolocation } from '../services/navigator-geolocation';\nimport { OptionBuilder } from '../services/option-builder';\nimport { toCamelCase } from '../services/util';\nimport { CustomMarkerOverlayViewService } from './custom-marker/services/custom-marker-overlay-view.service';\nimport { InfoWindow } from './info-window';\n\nconst INPUTS = [\n  'backgroundColor',\n  'center',\n  'disableDefaultUI',\n  'disableDoubleClickZoom',\n  'draggable',\n  'draggableCursor',\n  'draggingCursor',\n  'fullscreenControl',\n  'fullscreenControlOptions',\n  'geoFallbackCenter',\n  'heading',\n  'keyboardShortcuts',\n  'mapMaker',\n  'mapTypeControl',\n  'mapTypeControlOptions',\n  'mapTypeId',\n  'maxZoom',\n  'minZoom',\n  'noClear',\n  'options',\n  'overviewMapControl',\n  'overviewMapControlOptions',\n  'panControl',\n  'panControlOptions',\n  'rotateControl',\n  'rotateControlOptions',\n  'scaleControl',\n  'scaleControlOptions',\n  'scrollwheel',\n  'streetView',\n  'streetViewControl',\n  'streetViewControlOptions',\n  'styles',\n  'tilt',\n  'zoom',\n  'zoomControl',\n  'zoomControlOptions',\n  // ngui-map-specific inputs\n];\n\nconst OUTPUTS = [\n  'bounds_changed',\n  'center_changed',\n  'click',\n  'dblclick',\n  'drag',\n  'dragend',\n  'dragstart',\n  'heading_changed',\n  'idle',\n  'typeid_changed',\n  'mousemove',\n  'mouseout',\n  'mouseover',\n  'projection_changed',\n  'resize',\n  'rightclick',\n  'tilesloaded',\n  'tile_changed',\n  'zoom_changed',\n  // to avoid DOM event conflicts\n  'mapClick',\n  'mapMouseover',\n  'mapMouseout',\n  'mapMousemove',\n  'mapDrag',\n  'mapDragend',\n  'mapDragstart'\n];\n\n@Component({\n  selector: 'ngui-map',\n  providers: [\n    MapService,\n    OptionBuilder,\n    GeoCoder,\n    NavigatorGeolocation,\n    MapLoadedService,\n    CustomMarkerOverlayViewService,\n    MarkerClustererProviderService\n],\n  styles: [`\n    ngui-map {display: block; height: 300px;}\n    .google-map {width: 100%; height: 100%}\n  `],\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n  encapsulation: ViewEncapsulation.None,\n  template: `\n    <div class=\"google-map\"></div>\n    <ng-content></ng-content>\n  `,\n})\nexport class NguiMapComponent implements OnChanges, OnDestroy, AfterViewInit, AfterViewChecked {\n  @Output() public mapReady$: EventEmitter<any> = new EventEmitter();\n\n  public el: HTMLElement;\n  public map: google.maps.Map;\n  public mapOptions: google.maps.MapOptions = {};\n\n  public inputChanges$ = new Subject();\n\n  // map objects by group\n  public infoWindows: { [id: string]: InfoWindow } = { };\n\n  // map has been fully initialized\n  public mapIdledOnce: boolean = false;\n\n  private initializeMapAfterDisplayed = false;\n  private apiLoaderSub;\n\n  constructor(\n    public optionBuilder: OptionBuilder,\n    public elementRef: ElementRef,\n    public geolocation: NavigatorGeolocation,\n    public geoCoder: GeoCoder,\n    public nguiMap: MapService,\n    public apiLoader: NgMapApiLoader,\n    public zone: NgZone,\n    private readonly _mapLoadedService: MapLoadedService\n  ) {\n    apiLoader.load();\n\n    // all outputs needs to be initialized,\n    // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n    OUTPUTS.forEach(output => this[output] = new EventEmitter());\n  }\n\n  ngAfterViewInit() {\n    this.apiLoaderSub = this.apiLoader.api$.subscribe(() => this.initializeMap());\n  }\n\n  ngAfterViewChecked() {\n      if (this.initializeMapAfterDisplayed && this.el && this.el.offsetWidth > 0) {\n        this.initializeMap();\n      }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    this.inputChanges$.next(changes);\n  }\n\n  initializeMap(): void {\n    this.el = this.elementRef.nativeElement.querySelector('.google-map');\n    if (this.el && this.el.offsetWidth === 0) {\n        this.initializeMapAfterDisplayed = true;\n        return;\n    }\n\n    this.initializeMapAfterDisplayed = false;\n    this.mapOptions = this.optionBuilder.googlizeAllInputs(INPUTS, this);\n\n    this.mapOptions.zoom = this.mapOptions.zoom || 15;\n    typeof this.mapOptions.center === 'string' && (delete this.mapOptions.center);\n\n    this.zone.runOutsideAngular(() => {\n      this.map = new google.maps.Map(this.el, this.mapOptions);\n      this.map['mapObjectName'] = 'NguiMapComponent';\n\n      if (!this.mapOptions.center) { // if center is not given as lat/lng\n        this.setCenter();\n      }\n\n      // set google events listeners and emits to this outputs listeners\n      this.nguiMap.setObjectEvents(OUTPUTS, this, this.map);\n\n      this.map.addListener('idle', () => {\n        if (!this.mapIdledOnce) {\n          this.mapIdledOnce = true;\n          setTimeout(() => { // Why????, subsribe and emit must not be in the same cycle???\n            this.mapReady$.emit(this.map);\n            this._mapLoadedService.loaded();\n          });\n        }\n      });\n\n      // update map when input changes\n      this.inputChanges$\n        .pipe(debounceTime(1000))\n        .subscribe((changes: SimpleChanges) => this.nguiMap.updateGoogleObject(this.map, changes));\n\n      if (typeof window !== 'undefined' && (<any>window)['nguiMapRef']) {\n        // expose map object for test and debugging on (<any>window)\n        (<any>window)['nguiMapRef'].map = this.map;\n      }\n    });\n  }\n\n  setCenter(): void {\n    if (!this['center']) { // center is not from user. Thus, we set the current location\n      this.geolocation.getCurrentPosition().subscribe(\n        position => {\n          console.log('setting map center from current location');\n          let latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n          this.map.setCenter(latLng);\n        },\n        () => {\n          console.error('ngui-map: Error finding the current position');\n          this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        }\n      );\n    }\n    else if (typeof this['center'] === 'string') {\n      this.geoCoder.geocode({address: this['center']}).subscribe(\n        results => {\n          console.log('setting map center from address', this['center']);\n          this.map.setCenter(results[0].geometry.location);\n        },\n        () => {\n          this.map.setCenter(this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        });\n    }\n  }\n\n  openInfoWindow(id: string, anchor: google.maps.MVCObject) {\n    this.infoWindows[id].open(anchor);\n  }\n\n  closeInfoWindow(id: string) {\n    // if infoWindow for id exists, close the infoWindow\n    if (this.infoWindows[id])\n      this.infoWindows[id].close();\n  }\n\n  ngOnDestroy() {\n    this.inputChanges$.complete();\n    if (this.el && !this.initializeMapAfterDisplayed) {\n      this.nguiMap.clearObjectEvents(OUTPUTS, this, 'map');\n    }\n    if (this.apiLoaderSub) {\n      this.apiLoaderSub.unsubscribe();\n    }\n  }\n\n  // map.markers, map.circles, map.heatmapLayers.. etc\n  addToMapObjectGroup(mapObjectName: string, mapObject: any) {\n    let groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n    this.map[groupName] = this.map[groupName] || [];\n    this.map[groupName].push(mapObject);\n  }\n\n  // TODO:\n  // Why not just use mapObject.setMap(null);\n  removeFromMapObjectGroup(mapObjectName: string, mapObject: any) {\n    let groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n    if (this.map && this.map[groupName]) {\n      let index = this.map[groupName].indexOf(mapObject);\n      (index > -1) && this.map[groupName].splice(index, 1);\n    }\n  }\n}\n","import { Directive } from '@angular/core';\n\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = [];\nconst OUTPUTS = [ ];\n\n@Directive({\n  selector: 'ngui-map > bicycling-layer',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class BicyclingLayer extends BaseMapDirective {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'BicyclingLayer', INPUTS, OUTPUTS);\n  }\n}","import {\n    Component,\n    ElementRef,\n    EventEmitter,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    Output,\n    SimpleChanges,\n    ViewChild,\n    ViewContainerRef\n    } from '@angular/core';\nimport { debounceTime } from 'rxjs/operators';\nimport { Subject } from 'rxjs';\nimport { MapService } from '../services/map.service';\nimport { NguiMapComponent } from './ngui-map.component';\n\nconst INPUTS = [\n  'content', 'disableAutoPan', 'maxWidth', 'pixelOffset', 'position', 'zIndex', 'options'\n];\nconst OUTPUTS = [\n  'closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'\n];\n\n@Component({\n  selector: 'ngui-map > info-window',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n  template: `<div #template><ng-content></ng-content></div>`,\n})\nexport class InfoWindow implements OnInit, OnChanges, OnDestroy {\n  @Output() initialized$: EventEmitter<any> = new EventEmitter();\n\n  public infoWindow: google.maps.InfoWindow;\n  public objectOptions: google.maps.InfoWindowOptions = {};\n  public inputChanges$ = new Subject();\n  @ViewChild('template', {read: ViewContainerRef}) template: ViewContainerRef;\n\n  constructor(\n    private elementRef: ElementRef,\n    private nguiMap: MapService,\n    private nguiMapComponent: NguiMapComponent,\n  ) {\n    this.elementRef.nativeElement.style.display = 'none';\n    OUTPUTS.forEach(output => this[output] = new EventEmitter());\n  }\n\n  // Initialize this map object when map is ready\n  ngOnInit() {\n    if (this.nguiMapComponent.mapIdledOnce) { // map is ready already\n      this.initialize();\n    } else {\n      this.nguiMapComponent.mapReady$.subscribe(() => this.initialize());\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    this.inputChanges$.next(changes);\n  }\n\n  // called when map is ready\n  initialize(): void {\n    this.objectOptions = this.nguiMapComponent.optionBuilder.googlizeAllInputs(INPUTS, this);\n    this.infoWindow = new google.maps.InfoWindow(this.objectOptions);\n    this.infoWindow['mapObjectName'] = 'InfoWindow';\n\n    // register infoWindow ids to NguiMap, so that it can be opened by id\n    if (this.elementRef.nativeElement.id) {\n      this.nguiMapComponent.infoWindows[this.elementRef.nativeElement.id] = this;\n    } else {\n      console.error('An InfoWindow must have an id. e.g. id=\"detail\"');\n    }\n\n    // set google events listeners and emits to this outputs listeners\n    this.nguiMap.setObjectEvents(OUTPUTS, this, this.infoWindow);\n\n    // update object when input changes\n    this.inputChanges$\n        .pipe(debounceTime(1000))\n        .subscribe((changes: SimpleChanges) => this.nguiMap.updateGoogleObject(this.infoWindow, changes));\n\n    this.nguiMapComponent.addToMapObjectGroup('InfoWindow', this.infoWindow);\n    this.initialized$.emit(this.infoWindow);\n  }\n\n  open(anchor: google.maps.MVCObject) {\n    // set content and open it\n    this.infoWindow.setContent(this.template.element.nativeElement);\n    this.infoWindow.open(this.nguiMapComponent.map, anchor);\n  }\n  close() {\n    // check if infoWindow exists, and closes it\n    if (this.infoWindow)\n      this.infoWindow.close();\n  }\n  ngOnDestroy() {\n    this.inputChanges$.complete();\n    if (this.infoWindow) {\n      this.nguiMap.clearObjectEvents(OUTPUTS, this, 'infoWindow');\n      delete this.infoWindow;\n    }\n  }\n}\n","import { Directive } from '@angular/core';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { BaseMapDirective } from './base-map-directive';\n\n\nconst INPUTS = [\n  'center', 'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'map', 'radius',\n  'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options',\n  // ngui-map specific inputs\n  'geoFallbackCenter'\n];\nconst OUTPUTS = [\n  'centerChanged', 'click', 'dblclick', 'drag', 'dragend', 'dragstart',\n  'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'radiusChanged', 'rightclick',\n];\n\n@Directive({\n  selector: 'ngui-map>circle, ngui-map>map-circle',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class Circle extends BaseMapDirective {\n  public mapObject: google.maps.Circle;\n  public objectOptions: google.maps.CircleOptions = <google.maps.CircleOptions>{};\n\n  constructor(private nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'Circle', INPUTS, OUTPUTS);\n  }\n\n  initialize(): void {\n    super.initialize();\n    this.setCenter();\n  }\n\n  setCenter(): void {\n    if (!this['center']) {\n      this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(\n        center => {\n          console.log('setting circle center from current location');\n          let latLng = new google.maps.LatLng(center.coords.latitude, center.coords.longitude);\n          this.mapObject.setCenter(latLng);\n        },\n        () => {\n          console.error('ngui-map, error in finding the current position');\n          this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        }\n      ));\n    } else if (typeof this['center'] === 'string') {\n      this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({address: this['center']}).subscribe(\n        results => {\n          console.log('setting circle center from address', this['center']);\n          this.mapObject.setCenter(results[0].geometry.location);\n        },\n        () => {\n          console.error('ngui-map, error in finding location from', this['center']);\n          this.mapObject.setCenter(this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n        }\n      ));\n    }\n  }\n}\n","import { Directive } from '@angular/core';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { BaseMapDirective } from './base-map-directive';\n\n\nconst INPUTS = ['controlPosition', 'controls', 'drawingMode', 'featureFactory', 'style', 'geoJson', 'geoJsonUrl'];\nconst OUTPUTS = [\n  'addfeature', 'click', 'dblclick', 'mousedown', 'mouseout', 'mouseover',\n  'mouseup', 'removefeature', 'removeproperty', 'rightclick', 'setgeometry', 'setproperty'\n];\n\n@Directive({\n  selector: 'ngui-map > data-layer',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class DataLayer extends BaseMapDirective {\n  constructor(nguiMapComponent: NguiMapComponent) {\n    super(nguiMapComponent, 'Data', INPUTS, OUTPUTS);\n  }\n\n  // only called when map is ready\n  initialize(): void {\n    if (this['geoJson']) {\n      // addGeoJson from an object\n      console.log('this.geoJson', this['geoJson']);\n      this.nguiMapComponent.map.data.addGeoJson(this['geoJson']);\n    } else if (this['geoJsonUrl']) {\n      // loadGeoJson from a URL\n      console.log('this.geoJsonUrl', this['geoJsonUrl']);\n      this.nguiMapComponent.map.data.loadGeoJson(this['geoJsonUrl']);\n    }\n    else {\n      this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n      console.log(this.mapObjectName, 'initialization objectOptions', this.objectOptions);\n      this.nguiMapComponent.map.data.add(this.objectOptions);\n    }\n\n    // unlike others, data belongs to map. e.g., map.data.loadGeoJson(), map.data.add()\n    this.mapObject = this.nguiMapComponent.map.data;\n\n    // set google events listeners and emits to this outputs listeners\n    this.nguiMap.setObjectEvents(this.outputs, this, this.mapObject);\n\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  }\n}","import {\n    Directive,\n    Input,\n    OnChanges,\n    OnDestroy,\n    SimpleChanges\n    } from '@angular/core';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { NavigatorGeolocation } from '../services/navigator-geolocation';\nimport { BaseMapDirective } from './base-map-directive';\n\n\nconst INPUTS = [\n  'directions', 'draggable', 'hideRouteList', 'infoWindow', 'panel', 'markerOptions',\n  'polylineOptions', 'preserveViewport', 'routeIndex', 'suppressBicyclingLayer',\n  'suppressInfoWindows', 'suppressMarkers', 'suppressPolylines'\n];\nconst OUTPUTS = ['directions_changed'];\n\n@Directive({\n  selector: 'ngui-map > directions-renderer',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class DirectionsRenderer extends BaseMapDirective implements OnChanges, OnDestroy {\n  // tslint:disable-next-line\n  @Input('directions-request') directionsRequest: google.maps.DirectionsRequest;\n\n  directionsService: google.maps.DirectionsService;\n  directionsRenderer: google.maps.DirectionsRenderer;\n\n  constructor(\n    nguiMapComponent: NguiMapComponent,\n    public geolocation: NavigatorGeolocation\n  ) {\n    super(nguiMapComponent, 'DirectionsRenderer', INPUTS, OUTPUTS);\n  }\n\n  // only called when map is ready\n  initialize(): void {\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n    if (typeof this.objectOptions['panel'] === 'string') { // find a Node for panel\n      this.objectOptions['panel'] = document.querySelector(this.objectOptions['panel']);\n    }\n\n    console.log('DirectionsRenderer', 'initialization options', this.objectOptions, this.directionsRequest);\n\n    this.directionsService = new google.maps.DirectionsService();\n    this.directionsRenderer = new google.maps.DirectionsRenderer(this.objectOptions);\n\n    this.directionsRenderer.setMap(this.nguiMapComponent.map);\n\n    // set google events listeners and emidirectionsRenderer to this outputs listeners\n    this.showDirections(this.directionsRequest);\n\n    this.nguiMap.setObjectEvents(this.outputs, this, this.directionsRenderer);\n\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.directionsRenderer);\n  }\n\n\n  ngOnChanges(changes: SimpleChanges) {\n    let newOptions = {};\n    for (let key in changes) {\n      if (this.inputs.indexOf(key) !== -1) {\n        newOptions[key] = this.optionBuilder.googlize(changes[key].currentValue);\n      }\n    }\n    if (changes['directionsRequest'] && this.directionsRenderer) {\n      this.directionsService && this.showDirections(this.directionsRequest);\n    }\n  }\n\n  showDirections(directionsRequest: google.maps.DirectionsRequest) {\n    this.directionsService.route(directionsRequest,\n      (response: any, status: any) =>  {\n        // in some-case the callback is called during destroy component,\n        // we should make sure directionsRenderer is still defined (cancelling `route` callback is not possible).\n        if (!this.directionsRenderer) {\n          return;\n        }\n\n        if (status === google.maps.DirectionsStatus.OK) {\n          this.directionsRenderer.setDirections(response);\n        } else {\n          console.error('Directions request failed due to ' + status);\n        }\n      }\n    );\n  }\n\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    this.nguiMap.clearObjectEvents(this.outputs, this, 'directionsRenderer');\n  }\n}","import { Directive } from '@angular/core';\n\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = [\n  'options',\n  'circleOptions', 'drawingControl', 'drawingControlOptions', 'drawingMode',\n  'map', 'markerOptions', 'polygonOptions', 'polylineOptions', 'rectangleOptions'\n];\nconst OUTPUTS = [\n  'circlecomplete', 'markercomplete', 'overlaycomplete',\n  'polygoncomplete', 'polylinecomplete', 'rectanglecomplete'\n];\n\n@Directive({\n  selector: 'ngui-map > drawing-manager',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class DrawingManager extends BaseMapDirective {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'DrawingManager', INPUTS, OUTPUTS);\n    this.libraryName = 'drawing';\n  }\n}\n","import { Directive } from '@angular/core';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { BaseMapDirective } from './base-map-directive';\n\n\nconst INPUTS = [ 'url', 'bounds', 'clickable', 'opacity' ];\nconst OUTPUTS = [ 'click', 'dblclick' ];\n\n@Directive({\n  selector: 'ngui-map > ground-overlay',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class GroundOverlay extends BaseMapDirective {\n  public mapObject: google.maps.GroundOverlay;\n  public objectOptions: google.maps.GroundOverlayOptions = <google.maps.GroundOverlayOptions>{};\n\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'GroundOverlay', INPUTS, OUTPUTS);\n  }\n\n  // re-declaring initialize function. called when map is ready\n  initialize(): void {\n    // url, bounds are not the options of GroundOverlay\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(['clickable', 'opacity'], this);\n    console.log(this.mapObjectName, 'initialization objectOptions', this.objectOptions);\n\n    // noinspection TypeScriptUnresolvedFunction\n    this.mapObject = new google.maps.GroundOverlay(this['url'], this['bounds'], this.objectOptions);\n    this.mapObject.setMap(this.nguiMapComponent.map);\n    this.mapObject['mapObjectName'] = this.mapObjectName;\n\n    // set google events listeners and emits to this outputs listeners\n    this.nguiMap.setObjectEvents(this.outputs, this, this.mapObject);\n\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  }\n}\n\n","import { Directive } from '@angular/core';\n\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = [ 'data', 'dissipating', 'gradient', 'maxIntensity', 'opacity', 'radius', 'options' ];\nconst OUTPUTS = [];\n\n@Directive({\n  selector: 'ngui-map > heatmap-layer',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class HeatmapLayer extends BaseMapDirective {\n  public libraryName = 'visualization';\n\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'HeatmapLayer', INPUTS, OUTPUTS);\n  }\n}\n","import { Directive } from '@angular/core';\n\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = [ 'clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex', 'options' ];\nconst OUTPUTS = [ 'click', 'defaultviewport_changed', 'status_changed' ];\n\n@Directive({\n  selector: 'ngui-map > kml-layer',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class KmlLayer extends BaseMapDirective {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'KmlLayer', INPUTS, OUTPUTS);\n  }\n}\n","import {\n    Directive,\n    OnInit\n    } from '@angular/core';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { BaseMapDirective } from './base-map-directive';\n\n\nconst INPUTS = [\n  'anchorPoint', 'animation', 'clickable', 'cursor', 'draggable', 'icon', 'label', 'opacity',\n  'optimized', 'place', 'position', 'shape', 'title', 'visible', 'zIndex', 'options',\n  // ngui-map specific inputs\n  'geoFallbackPosition'\n];\nconst OUTPUTS = [\n  'animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged',\n  'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick',\n  'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged'\n];\n\n@Directive({\n  selector: 'ngui-map > marker',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class Marker extends BaseMapDirective implements OnInit {\n  public mapObject: google.maps.Marker;\n  public objectOptions: google.maps.MarkerOptions = <google.maps.MarkerOptions>{};\n\n  constructor(private nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'Marker', INPUTS, OUTPUTS);\n  }\n\n  // Initialize this map object when map is ready\n  ngOnInit() {\n    if (this.nguiMapComponent.mapIdledOnce) { // map is ready already\n      this.initialize();\n    } else {\n      this.nguiMapComponent.mapReady$.subscribe(() => this.initialize());\n    }\n  }\n\n  initialize(): void {\n    super.initialize();\n    this.setPosition();\n  }\n\n  setPosition(): void {\n    if (!this['position']) {\n      this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(\n        position => {\n          let latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n          this.mapObject.setPosition(latLng);\n        },\n        () => {\n          this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n        }\n      ));\n    } else if (typeof this['position'] === 'string') {\n      this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({address: this['position']}).subscribe(\n        results => {\n          this.mapObject.setPosition(results[0].geometry.location);\n        },\n        () => {\n          this.mapObject.setPosition(this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n        }\n      ));\n    }\n  }\n}\n","import { NgMapApiLoader } from '../services/api-loader';\nimport { OptionBuilder } from '../services/option-builder';\nimport { missingLibraryError } from '../services/util';\nimport {\n  Input,\n  Output,\n  Directive,\n  EventEmitter,\n  ElementRef,\n} from '@angular/core';\n\n\n@Directive({\n  selector: '[places-auto-complete]'\n})\nexport class PlacesAutoComplete {\n  @Input('bounds') bounds: any;\n  @Input('componentRestrictions') componentRestrictions: any;\n  @Input('types') types: string[];\n\n  @Output('place_changed') place_changed: EventEmitter<any> = new EventEmitter();\n  @Output() initialized$: EventEmitter<any> = new EventEmitter();\n\n  public objectOptions: any;\n  public autocomplete: google.maps.places.Autocomplete;\n\n  constructor(\n    public optionBuilder: OptionBuilder,\n    public elementRef: ElementRef,\n    public apiLoader: NgMapApiLoader,\n  ) {\n    apiLoader.load();\n    apiLoader.api$.subscribe(() => this.initialize());\n  }\n\n  // only called when map is ready\n  initialize = (): void => {\n    this.objectOptions =\n      this.optionBuilder.googlizeAllInputs(['bounds', 'componentRestrictions', 'types'], this);\n\n    if (!google.maps.places) {\n      throw missingLibraryError('PlacesAutoComplete', 'places');\n    }\n\n    this.autocomplete = new google.maps.places.Autocomplete(\n      this.elementRef.nativeElement,\n      this.objectOptions\n    );\n\n    this.autocomplete.addListener('place_changed', () => {\n      this.place_changed.emit(this.autocomplete.getPlace());\n    });\n\n    this.initialized$.emit(this.autocomplete);\n  }\n}\n","import { Directive } from '@angular/core';\n\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = [\n  'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'paths',\n  'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options',\n];\nconst OUTPUTS = [\n  'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown',\n  'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick',\n];\n\n@Directive({\n  selector: 'ngui-map>polygon, ngui-map>map-polygon',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class Polygon extends BaseMapDirective {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'Polygon', INPUTS, OUTPUTS);\n  }\n}\n","import { Directive } from '@angular/core';\n\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = [\n  'clickable', 'draggable', 'editable', 'geodesic', 'icons', 'path', 'strokeColor',\n  'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'options'\n];\nconst OUTPUTS = [\n  'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown',\n  'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'\n];\n\n@Directive({\n  selector: 'ngui-map > polyline',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class Polyline extends BaseMapDirective {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'Polyline', INPUTS, OUTPUTS);\n  }\n}\n\n","import {\n    Directive,\n    OnDestroy\n    } from '@angular/core';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { BaseMapDirective } from './base-map-directive';\n\n\nconst INPUTS = [\n  'selector', 'options',\n  'addressControl', 'addressControlOptions', 'clickToGo', 'disableDefaultUI', 'disableDoubleClickZoom',\n  'enableCloseButton', 'fullscreenControl', 'fullscreenControlOptions', 'imageDateControl', 'linksControl',\n  'motionTracking', 'motionTrackingControl', 'panControl', 'panControlOptions', 'pano',\n  'position', 'pov', 'scrollwheel', 'showRoadLabels', 'visible', 'zoomControl', 'zoomControlOptions'\n];\nconst OUTPUTS = [\n  'closeclick', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'status_changed',\n  'visible_changed', 'zoom_changed'\n];\n\n@Directive({\n  selector: 'ngui-map > street-view-panorama',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class StreetViewPanorama extends BaseMapDirective implements OnDestroy {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'StreetViewPanorama', INPUTS, OUTPUTS);\n  }\n\n  // only called when map is ready\n  initialize(): void {\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n    console.log(this.mapObjectName, 'initialization objectOptions', this.objectOptions);\n\n    let element: HTMLElement;\n    if (this.objectOptions.selector) {\n      // noinspection TypeScriptValidateTypes\n      element = document.querySelector(this['selector']);\n      delete this.objectOptions.selector;\n    } else {\n      element = this.nguiMapComponent.el;\n    }\n\n    // will be set after geocoded\n    typeof this.objectOptions.position === 'string' && (delete this.objectOptions.position);\n\n    this.mapObject = new google.maps[this.mapObjectName](element, this.objectOptions);\n    this.mapObject['mapObjectName'] = this.mapObjectName;\n    this.mapObject['nguiMapComponent'] = this.nguiMapComponent;\n\n    // set google events listeners and emits to this outputs listeners\n    this.nguiMap.setObjectEvents(this.outputs, this, this.mapObject);\n\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  }\n\n  // When destroyed, remove event listener, and delete this object to prevent memory leak\n  ngOnDestroy() {\n    if (this.nguiMapComponent.el) {\n      this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n    }\n  }\n}","import { Directive } from '@angular/core';\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = ['autoRefresh', 'options' ];\nconst OUTPUTS = [ ];\n\n@Directive({\n  selector: 'ngui-map > traffic-layer',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class TrafficLayer extends BaseMapDirective {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'TrafficLayer', INPUTS, OUTPUTS);\n  }\n}","import { Directive } from '@angular/core';\n\nimport { BaseMapDirective } from './base-map-directive';\nimport { NguiMapComponent } from '../components/ngui-map.component';\n\nconst INPUTS = [];\nconst OUTPUTS = [ ];\n\n@Directive({\n  selector: 'ngui-map > transit-layer',\n  inputs: INPUTS,\n  outputs: OUTPUTS,\n})\nexport class TransitLayer extends BaseMapDirective {\n  constructor(nguiMapComp: NguiMapComponent) {\n    super(nguiMapComp, 'TransitLayer', INPUTS, OUTPUTS);\n  }\n}","import {\n    ChangeDetectionStrategy,\n    OnChanges,\n    SimpleChanges\n    } from '@angular/core';\nimport { takeUntil } from 'rxjs/operators';\nimport { ReplaySubject ,  Subject } from 'rxjs';\nimport { MapService } from '../../services/map.service';\nimport { CustomMarkerOverlayViewService } from '../custom-marker/services/custom-marker-overlay-view.service';\nimport { NguiMapComponent } from '../ngui-map.component';\nimport {\n    Component,\n    ElementRef,\n    EventEmitter,\n    Input,\n    OnDestroy,\n    OnInit,\n    Output,\n    } from '@angular/core';\n\n// const INPUTS = [\n//     'position'\n// ];\n// to avoid DOM event conflicts map_*\nconst OUTPUTS = [\n//     'animationChanged',\n     'click',\n//     'clickableChanged',\n//     'cursorChanged',\n//     'dblclick',\n//     'drag',\n     'dragend',\n//     'draggableChanged',\n//     'dragstart',\n//     'flatChanged',\n//     'iconChanged',\n//     'map_click',\n//     'map_drag',\n//     'map_dragend',\n//     'map_mousedown',\n//     'map_mouseout',\n//     'map_mouseover',\n//     'map_mouseup',\n//     'mousedown',\n//     'mouseout',\n//     'mouseover',\n//     'mouseup',\n//     'positionChanged',\n//     'rightclick',\n//     'shapeChanged',\n//     'titleChanged',\n//     'visibleChanged',\n//     'zindexChanged'\n];\n\n// TODO: should be directive\n@Component({\n    selector: 'ngui-map > custom-marker',\n    // inputs: INPUTS,\n    outputs: OUTPUTS,\n    template: `\n      <ng-content>\n      </ng-content>\n    `,\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class CustomMarkerComponent implements OnInit, OnDestroy, OnChanges {\n    @Output() initialized: EventEmitter<any> = new EventEmitter();\n\n    @Input() draggable: boolean = false;\n    @Input() position: { lat: string, lng: string };\n    @Input() attachToParentMap: boolean = true;\n\n    intialized$ = new ReplaySubject(1);\n    overlay: any;\n\n    // private _inputChange: Subject<SimpleChanges> = new Subject<SimpleChanges>();\n    private _el: HTMLElement;\n    private readonly _destroyed$ = new Subject();\n\n    constructor(\n        private readonly _customMarkerOverlayViewService: CustomMarkerOverlayViewService,\n        private readonly _nguiMapComponent: NguiMapComponent,\n        private readonly _elementRef: ElementRef,\n        private readonly _mapService: MapService\n    ) {\n        this._elementRef.nativeElement.style.display = 'none';\n        OUTPUTS.forEach(output => this[output] = new EventEmitter());\n    }\n\n    ngOnInit() {\n        this._customMarkerOverlayViewService.overlayDefined$\n            .pipe(takeUntil(this._destroyed$))\n            .subscribe(() => this._init());\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        // this._inputChange.next(changes);\n\n        if (changes['draggable'] && this.overlay) {\n            this.overlay.setDraggable(this.draggable);\n        }\n\n        if (changes['position'] && this.overlay) {\n            this.overlay.setPosition(\n                new google.maps.LatLng(\n                    +this.position.lat,\n                    +this.position.lng\n                )\n            );\n        }\n    }\n\n    ngOnDestroy() {\n        // this._inputChange.complete();\n        // TODO not sure if this is needed\n        // this.overlay.setMap(null);\n        // this.nguiMapComponent.removeFromMapObjectGroup('CustomMarker', this._markerOverlay);\n\n        if (this.overlay) {\n            this._mapService.clearObjectEvents(OUTPUTS, this, 'overlay');\n        }\n    }\n\n    private _init(): void {\n        this._el = this._elementRef.nativeElement;\n\n        this.overlay = new this._customMarkerOverlayViewService.CustomMarkerOverlayView(\n            this._el,\n            this['position'],\n            this.draggable\n        );\n\n        if (this.attachToParentMap) {\n            this.overlay.setMap(this._nguiMapComponent.map);\n        }\n\n        // set google events listeners and emits to this outputs listeners\n        // TODO: I dont this this is needed\n        this._mapService.setObjectEvents(OUTPUTS, this, this.overlay);\n\n        // update object when input changes\n        // TODO: makes sense to remove that for performance\n        // this._inputChange\n        //     .pipe(debounceTime(1000))\n        //     .subscribe((changes: SimpleChanges) =>\n        //         this._mapService.updateGoogleObject(this._markerOverlay, changes));\n\n        // this.nguiMapComponent.addToMapObjectGroup('CustomMarker', this._markerOverlay);\n        this.initialized.emit(this.overlay);\n        this.intialized$.next(this.overlay);\n    }\n}\n","import {\n    ContentChildren,\n    Directive,\n    EventEmitter,\n    Input,\n    OnDestroy,\n    OnInit,\n    QueryList\n    } from '@angular/core';\nimport { combineLatest as combine ,  of } from 'rxjs';\nimport {\n    combineLatest,\n    filter,\n    first\n    } from 'rxjs/operators';\nimport { CustomMarkerComponent } from '../components/custom-marker/custom-marker.component';\nimport { NguiMapComponent } from '../components/ngui-map.component';\nimport { MapLoadedService } from '../services/map-loaded.service';\nimport { MapService } from '../services/map.service';\nimport { MarkerClustererProviderService } from '../services/marker-clusterer-provider.service';\n\nconst getDefaultImageInline = (color: string = '#004b7a') => `\n    <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n        viewBox=\"-100 -100 200 200\">\n        <defs>\n            <g\n                id=\"a\"\n                transform=\"rotate(45)\">\n                <path\n                    d=\"M0 47A47 47 0 0 0 47 0L62 0A62 62 0 0 1 0 62Z\"\n                    fill-opacity=\"0.7\"/>\n                <path\n                    d=\"M0 67A67 67 0 0 0 67 0L81 0A81 81 0 0 1 0 81Z\"\n                    fill-opacity=\"0.5\"/>\n                <path\n                    d=\"M0 86A86 86 0 0 0 86 0L100 0A100 100 0 0 1 0 100Z\"\n                    fill-opacity=\"0.3\"/>\n            </g>\n        </defs>\n        <g transform=\"rotate(${Math.round(Math.random() * 120)})\" fill=\"${color}\">\n            <circle r=\"42\"/>\n            <g>\n                <use xlink:href=\"#a\"/>\n            </g>\n            <g transform=\"rotate(120)\">\n                <use xlink:href=\"#a\"/>\n            </g>\n            <g transform=\"rotate(240)\">\n                <use xlink:href=\"#a\"/>\n            </g>\n        </g>\n    </svg>\n`;\n\nconst outputs = [\n    'click',\n    'clusteringbegin',\n    'clusteringend',\n    'mouseout',\n    'mouseover'\n];\n\n@Directive({\n    selector: 'custom-marker-cluster',\n    outputs\n})\nexport class CustomMarkerClusterDirective implements OnInit, OnDestroy {\n    /**\n     * Default styles are: {\n     *     width: 40,\n     *     height: 40,\n     *     textColor: 'white',\n     *     textSize: 12,\n     *     url: undefined\n     * }\n     */\n    @Input() set clusterStyles(clusterStyles: ClusterIconStyle) {\n        this._clusterStyles = {\n            ...this._defaultClusterStyles,\n            ...clusterStyles || {}\n        };\n    }\n\n    /**\n     * Image of cluster\n     * In case rawImage is provided color property will not be used\n     */\n    @Input() rawImage: string;\n\n    /**\n     * Color of the cluster image, this cannot be changed during cluster life\n     * But that can be done if needed\n     */\n    @Input() color: string;\n\n    /**\n     * Configuration options for marker clusterer\n     * Default options are { averageCenter: true, maxZoom: 12 }\n     * Dont use styles because these will be overriden\n     */\n    @Input() set options(options: MarkerClustererOptions) {\n        this._options = { ...this._defaultOptions, ...(options || {}) };\n    }\n\n    @ContentChildren(CustomMarkerComponent)\n    set customMarkers (customMarkers: QueryList<CustomMarkerComponent>) {\n        this._customMarkers = customMarkers;\n        this._updateMarkers();\n    }\n\n    cluster: MarkerClusterer;\n\n    private readonly _defaultOptions = { averageCenter: true, maxZoom: 12 };\n    private readonly _defaultClusterStyles = {\n        width: 40,\n        height: 40,\n        textColor: 'white',\n        textSize: 12,\n        url: undefined\n    };\n\n    private MarkerClusterer: typeof MarkerClusterer;\n    private _clusterStyles: ClusterIconStyle = this._defaultClusterStyles;\n    private _options: MarkerClustererOptions = this._defaultOptions;\n    private _markerOverlays: any[];\n    private _map: google.maps.Map;\n    private _customMarkers: QueryList<CustomMarkerComponent>;\n\n    constructor(\n        private readonly _markerClustererProviderService: MarkerClustererProviderService,\n        private readonly _mapLoadedService: MapLoadedService,\n        private readonly _mapService: MapService,\n        private readonly _nguiMapComponent: NguiMapComponent\n    ) {\n        outputs.forEach((eventName: string) => this[eventName] = new EventEmitter());\n    }\n\n    ngOnInit(): void {\n        this._mapLoadedService.loaded$\n            .pipe(\n                filter(Boolean),\n                combineLatest(this._markerClustererProviderService.getClusterer()),\n                first())\n            .subscribe(([, MarkerClusterer]) => {\n                this.MarkerClusterer = MarkerClusterer;\n                this._map = this._nguiMapComponent.map;\n                this._initCluster();\n            });\n    }\n\n    ngOnDestroy(): void {\n        this._removeCluster();\n    }\n\n    private _updateMarkers() {\n        (this._customMarkers.length === 0\n            ? of([])\n            : combine(\n                ...this._customMarkers.map(\n                    (customMarkerCmp: CustomMarkerComponent) =>\n                            customMarkerCmp.intialized$)))\n                .subscribe((overlays: any[]) => {\n                    this._markerOverlays = overlays;\n                    this.cluster\n                        ? this._reloadClusterOverlays()\n                        : this._initCluster();\n                });\n    }\n\n    private _initCluster(): void {\n        if (this.cluster) {\n            this._removeCluster();\n        }\n\n        if (!this.MarkerClusterer ||\n            !this._map ||\n            !this._markerOverlays) {\n            return;\n        }\n\n        this.cluster = new this.MarkerClusterer(\n            this._map,\n            this._markerOverlays,\n            { ...this._options, styles: this._getClusterStyles() }\n        );\n\n        this._mapService.setObjectEvents(outputs, this, this.cluster);\n    }\n\n    private _removeCluster(): void {\n        this.cluster && this.cluster.clearMarkers();\n        this._mapService.clearObjectEvents(outputs, this, 'cluster');\n    }\n\n    private _reloadClusterOverlays(): void {\n        if (!this.cluster || ! this._markerOverlays) {\n            return;\n        }\n\n        this.cluster.clearMarkers();\n\n        this.cluster.addMarkers(this._markerOverlays);\n    }\n\n    private _getClusterStyles() {\n        return [{\n            ...this._clusterStyles,\n            url: this._getGoogleClusterInlineSvg(),\n        }];\n    }\n\n    private _getGoogleClusterInlineSvg() {\n        const encoded = window.btoa(\n            this.rawImage || getDefaultImageInline(this.color)\n        );\n\n        return `data:image/svg+xml;base64,${encoded}`;\n    }\n}","\nimport { isArray } from '../util/isArray';\nimport { CombineLatestOperator } from '../observable/combineLatest';\nimport { from } from '../observable/from';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\n\nconst none = {};\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static combineLatest.\n */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  let project: (...values: Array<any>) => R = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = (<any>observables[0]).slice();\n  }\n\n  return (source: Observable<T>) => source.lift.call(from([source, ...observables]), new CombineLatestOperator(project));\n}\n","import { CommonModule } from '@angular/common';\nimport {\n    ModuleWithProviders,\n    NgModule\n    } from '@angular/core';\nimport { CustomMarkerComponent } from './components/custom-marker/custom-marker.component';\nimport { InfoWindow } from './components/info-window';\nimport { NguiMapComponent } from './components/ngui-map.component';\nimport { BicyclingLayer } from './directives/bicycling-layer';\nimport { Circle } from './directives/circle';\nimport { CustomMarkerClusterDirective } from './directives/custom-marker-cluster.directive';\nimport { DataLayer } from './directives/data-layer';\nimport { DirectionsRenderer } from './directives/directions-renderer';\nimport { DrawingManager } from './directives/drawing-manager';\nimport { GroundOverlay } from './directives/ground-overlay';\nimport { HeatmapLayer } from './directives/heatmap-layer';\nimport { KmlLayer } from './directives/kml-layer';\nimport { Marker } from './directives/marker';\nimport { PlacesAutoComplete } from './directives/places-auto-complete';\nimport { Polygon } from './directives/polygon';\nimport { Polyline } from './directives/polyline';\nimport { StreetViewPanorama } from './directives/street-view-panorama';\nimport { TrafficLayer } from './directives/traffic-layer';\nimport { TransitLayer } from './directives/transit-layer';\nimport {\n    NgMapApiLoader,\n    NgMapAsyncApiLoader\n    } from './services/api-loader';\nimport {\n    ConfigOption,\n    NG_MAP_CONFIG_TOKEN\n    } from './services/config';\nimport { GeoCoder } from './services/geo-coder';\nimport { MapService } from './services/map.service';\nimport { NavigatorGeolocation } from './services/navigator-geolocation';\nimport { OptionBuilder } from './services/option-builder';\n\nconst COMPONENTS_DIRECTIVES = [\n    BicyclingLayer,\n    Circle,\n    CustomMarkerClusterDirective,\n    CustomMarkerComponent,\n    DataLayer,\n    DirectionsRenderer,\n    DrawingManager,\n    GroundOverlay,\n    HeatmapLayer,\n    InfoWindow,\n    InfoWindow,\n    KmlLayer,\n    Marker,\n    NguiMapComponent,\n    PlacesAutoComplete,\n    Polygon,\n    Polyline,\n    StreetViewPanorama,\n    TrafficLayer,\n    TransitLayer,\n];\n\n@NgModule({\n    imports: [CommonModule],\n    declarations: COMPONENTS_DIRECTIVES,\n    exports: [COMPONENTS_DIRECTIVES],\n    providers: [\n        GeoCoder,\n        NavigatorGeolocation,\n        MapService,\n        OptionBuilder,\n        { provide: NgMapApiLoader, useClass: NgMapAsyncApiLoader }\n    ]\n})\nexport class NguiMapModule {\n  static forRoot(config: ConfigOption = {}): ModuleWithProviders {\n    return {\n      ngModule: NguiMapModule,\n      providers: [{ provide: NG_MAP_CONFIG_TOKEN, useValue: config }]\n    };\n  }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","isFunction","x","_enable_super_gross_mode_that_will_cause_bad_things","config","Promise","undefined","useDeprecatedSynchronousErrorHandling","value","Error","stack","hostReportError","err","setTimeout","empty","closed","next","error","complete","isObject","tryCatchTarget","tryCatcher","apply","arguments","e","errorObject","tryCatch","fn","UnsubscriptionError","_super","errors","_this","call","length","map","i","toString","join","name","tslib_1.__extends","Subscription","unsubscribe","_parent","_parents","_subscriptions","_unsubscribe","hasErrors","index","len","remove","flattenUnsubscriptionErrors","isArray","sub","concat","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","reduce","errs","rxSubscriber","Symbol","for","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","emptyObserver","isTrustedSubscriber","obj","rxSubscriberSymbol","trustedSubscriber","SafeSubscriber","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","Observable","subscribe","_isScalar","_subscribe","lift","operator","observable","source","sink","toSubscriber","nextOrObserver","_trySubscribe","forEach","promiseCtor","getPromiseCtor","resolve","reject","Symbol_observable","pipe","operations","_i","pipeFromArray","fns","input","prev","noop","toPromise","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","AnonymousSubject","copy","slice","thrownError","asObservable","refCount","RefCountOperator","connectable","_refCount","refCounter","RefCountSubscriber","connection","connect","sharedConnection","_connection","connectableProto","ConnectableObservable","subjectFactory","getSubject","_subject","_isComplete","ConnectableSubscriber","higherOrderRefCount","connectableObservableDescriptor","writable","BehaviorSubject","_value","defineProperty","get","getValue","configurable","AsyncAction","scheduler","work","schedule","state","delay","id","recycleAsyncId","pending","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","actions","Action","QueueAction","Scheduler","SchedulerAction","now","AsyncScheduler","delegate","active","scheduled","action","shift","queue","QueueScheduler","empty$1","emptyScheduled","isScheduler","subscribeToArray","array","fromArray","of","args","pop","scalar","result","throwError","dispatch","_a","Notification","kind","hasValue","observe","observer","do","accept","toObservable","createNext","undefinedValueNotification","createError","createComplete","completeNotification","ObserveOnSubscriber","arg","notification","scheduleMessage","ObserveOnMessage","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_events","_infiniteTimeWindow","_bufferSize","_windowTime","nextTimeWindow","nextInfiniteTimeWindow","ReplayEvent","_getNow","_trimBufferThenGetEvents","eventsCount","spliceCount","time","Math","max","async","identity","ArgumentOutOfRangeError","EmptyError","project","thisArg","mapOperation","TypeError","MapOperator","MapSubscriber","count","OuterSubscriber","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","InnerSubscriber","subscribeToPromise","promise","then","getSymbolIterator","iterator","subscribeToIterable","iterable","Symbol_iterator","item","done","return","subscribeToObservable","obs","isPromise","subscribeTo","isArrayLike","subscribeToResult","outerSubscriber","NONE","CombineLatestOperator","resultSelector","CombineLatestSubscriber","values","observables","toRespond","unused","oldVal","_tryResultSelector","from","isInteropObservable","fromObservable","fromPromise","isIterable","fromIterable","_isPlaceholder","a","_curry1","f1","always","val","_curry2","f2","_b","curryN","_arity","_curryN","_curry3","f3","c","_c","_isArray","_isString","nodeType","thisObj","_xmap","f","xf","XMap","_has","prop","hasEnumBug","propertyIsEnumerable","nonEnumerableProps","hasArgsEnumBug","contains","list","idx","isNil","keys","nIdx","ks","checkArgsLength","_isArguments","functor","_reduce","acc","key","_map","path","paths","pluck","ap","applyF","applyX","_concat","liftN","arity","lifted","_xchain","_flatCat","chain","monad","_makeFlat","recursive","flatt","jlen","j","ilen","_isArrayLike","type","not","_checkForMethod","methodname","fromIndex","toIndex","Infinity","reverse","split","identical","equals","_equals","pad","n","Date","toISOString","_toISOString","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","toFixed","_xfilter","XFilter","pred","filterable","filter","_complement","converge","after","_xreduceBy","valueFn","valueAcc","keyFn","XReduceBy","reduceBy","elt","_xdropRepeatsWith","XDropRepeatsWith","nth","offset","charAt","dropRepeatsWith","last","flip","invoker","method","target","_isFunction","juxt","multiply","pickAll","names","ws","String","trim","toCamelCase","str","replace","letter","toLowerCase","toUpperCase","missingLibraryError","component","libName","loadScript","url","scriptId","window","loadedObjKey","observableThrowError","storage","document","querySelector","scriptState","isNilR","script","createElement","src","onload","appendChild","BaseMapDirective","nguiMapComponent","mapObjectName","inputs","outputs","_this_1","initialized$","EventEmitter","nguiMap","optionBuilder","output","ngOnInit","mapIdledOnce","initialize","mapReady$","objectOptions","googlizeAllInputs","position","center","libraryName","google","maps","mapObject","setMap","setObjectEvents","addToMapObjectGroup","emit","ngOnChanges","changes","updateGoogleObject","ngOnDestroy","removeFromMapObjectGroup","clearObjectEvents","propDecorators","Output","debounceTime","dueTime","DebounceTimeOperator","DebounceTimeSubscriber","lastValue","clearDebounce","debouncedSubscription","dispatchNext","debouncedNext","DefaultIfEmptyOperator","defaultValue","DefaultIfEmptySubscriber","isEmpty","filter$2","predicate","FilterOperator","FilterSubscriber","DoOperator","TapSubscriber","_tapNext","_tapError","_tapComplete","throwIfEmpty","errorFactory","defaultErrorFactory","tap$2","tap","TakeOperator","total","TakeSubscriber","first","hasDefaultValue","v","take$2","take","defaultIfEmpty","MulticastOperator","selector","publishReplay","selectorOrScheduler","multicast","subjectOrSubjectFactory","TakeUntilOperator","notifier","takeUntilSubscriber","TakeUntilSubscriber","notifierSubscription","NG_MAP_CONFIG_TOKEN","InjectionToken","NgMapApiLoader","api$","defaultConf","apiUrl","assign","load","NgMapAsyncApiLoader","_super_1","isMapsApiLoaded","apiLoaded","loaded","decorators","Injectable","ctorParameters","Optional","Inject","GeoCoder","apiLoader","apiLoaderSubs","geocode","options","responseObserver","requestGeocode","Geocoder","results","status","GeocoderStatus","OK","MapLoadedService","isLoaded","_loaded$","loaded$","OptionBuilder","definedInputs","userInputs","console","log","onlyOptionsGiven","googlize","googlizeMultiple","match","getJSONParsed","getAnyMapObject","getAnyMapConstant","getDateObject","LatLngBounds","getMapIcons","getLatLng","getMarkerIcon","getMapControlOption","el","LatLng","isNaN","parseFloat","isFinite","getJSON","JSON","parse","jsonize","_","$1","newOptions","Function","matches","capitalizedKey","controlOptions","newControlOptions","MapTypeId","objName","ControlPosition","icon","SymbolPath","MapService","geoCoder","zone","object","currentValue","setMethodName","address","geometry","location","definedEvents","componentInstance","definedEvent","eventName","normalizeEventName","runOutsideAngular","addListener","event","param","run","prefix","clearListeners","NgZone","MarkerClustererProviderService","clustererLibUrl","getClusterer","MarkerClusterer$","MarkerClusterer","NavigatorGeolocation","getCurrentPosition","geoLocationOptions","timeout","navigator","geolocation","evt","CustomMarkerOverlayViewService","_mapLoadedService","_overlayDefined$","overlayDefined$","Boolean","CustomMarkerOverlayView","OverlayView","class_1","_d","setPosition","_position","projection","getProjection","posPixel","fromLatLngToDivPixel","_htmlElement","style","left","round","top","y","_draggable","lat","lng","Map","getDiv","onAdd","getPanes","overlayMouseTarget","draw","setZIndex","_zIndex","setVisible","onRemove","clearInstanceListeners","_mouseLeaveMapListener","parentElement","removeChild","getPosition","_initDraggable","zIndex","visible","display","setDraggable","draggable","_disposeDragEvents","getDraggable","_mouseDownListerer","_mouseUpListener","_moveHandler","addDomListener","mapElement","_dragOrigin","_onDragEnd","set","origin","leftOffset","clientX","topOffset","clientY","currentPositionPx","nextLatLng","fromDivPixelToLatLng","Point","trigger","INPUTS","OUTPUTS","NguiMapComponent","elementRef","mapOptions","inputChanges$","infoWindows","initializeMapAfterDisplayed","ngAfterViewInit","apiLoaderSub","initializeMap","ngAfterViewChecked","offsetWidth","nativeElement","zoom","setCenter","latLng","coords","latitude","longitude","openInfoWindow","anchor","open","closeInfoWindow","close","groupName","Component","providers","styles","encapsulation","ViewEncapsulation","None","template","ElementRef","BicyclingLayer","nguiMapComp","Directive","InfoWindow","infoWindow","setContent","element","ViewChild","read","ViewContainerRef","Circle","DataLayer","data","addGeoJson","loadGeoJson","DirectionsRenderer","directionsRequest","directionsService","DirectionsService","directionsRenderer","showDirections","route","response","DirectionsStatus","setDirections","Input","DrawingManager","GroundOverlay","HeatmapLayer","KmlLayer","Marker","PlacesAutoComplete","place_changed","places","autocomplete","Autocomplete","getPlace","bounds","componentRestrictions","types","Polygon","Polyline","StreetViewPanorama","TrafficLayer","TransitLayer","CustomMarkerComponent","_customMarkerOverlayViewService","_nguiMapComponent","_elementRef","_mapService","initialized","attachToParentMap","intialized$","_destroyed$","takeUntil","_init","overlay","_el","changeDetection","ChangeDetectionStrategy","OnPush","CustomMarkerClusterDirective","_markerClustererProviderService","_defaultOptions","averageCenter","maxZoom","_defaultClusterStyles","width","height","textColor","textSize","_clusterStyles","_options","clusterStyles","customMarkers","_customMarkers","_updateMarkers","combineLatest$1","combineLatest","_initCluster","_removeCluster","combine","customMarkerCmp","overlays","_markerOverlays","cluster","_reloadClusterOverlays","_getClusterStyles","clearMarkers","addMarkers","_getGoogleClusterInlineSvg","color","btoa","rawImage","random","ContentChildren","COMPONENTS_DIRECTIVES","NguiMapModule","forRoot","ngModule","provide","useValue","NgModule","imports","CommonModule","declarations","exports","useClass"],"mappings":"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"}
